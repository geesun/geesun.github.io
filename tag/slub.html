<!DOCTYPE html>
<html lang="cn">
<head>
        <meta charset="utf-8" />
        <title>Linux学习笔记 - SLUB</title>
        <link rel="stylesheet" href="../theme/css/main.css" />

        <!--[if IE]>
            <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="../">Linux学习笔记 </a></h1>
                <nav><ul>
                    <li><a href="../category/linux.html">Linux</a></li>
                </ul>
                </nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="../posts/2024/06/slub_alloc.html">slub分配器的理解</a></h1>
<footer class="post-info">
        <span>一 24 六月 2024</span>
<span>| tags: <a href="../tag/linux.html">Linux</a><a href="../tag/mmu.html">MMU</a><a href="../tag/slub.html">SLUB</a></span>
</footer><!-- /.post-info --><p>slub分配器的原理，<a class="reference external" href="http://www.wowotech.net/memory_management/426.html">这里</a> 已经分析的很清楚。</p>
<p>这里主要记录我对这个的理解，怕以后忘记。</p>
<div class="section" id="section-1">
<h2>关键数据结构</h2>
<ol class="arabic simple">
<li>struct kmem_cache</li>
</ol>
<p>这个是slub分配器的总管，如果要针对特定大小，特定用途的内存有一个分配器的话，那就必须要创建这个结构。 而每次分配内存的时候，需要把这个结构传递给分配器。</p>
<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#ifndef CONFIG_SLUB_TINY</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache_cpu</span><span class="w"> </span><span class="n">__percpu</span><span class="w"> </span><span class="o">*</span><span class="n">cpu_slab</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="w">        </span><span class="c1">//..</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache_node</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
<p>cpu_slab 是每个cpu都有自己的copy，这样每个cpu首先要在自己的cache里面进行分配，在这个cache pool里面分配是不需要锁的，毕竟这个cache pool只给这个CPU分配。 这样会大大提高效率。</p>
<p>node 这个变量跟NUMA有关系，在分配内存的时候，肯定是希望尽可能分配的内存使这个CPU访问的效率最高。 所以当cpu_slab没法满足分配的时，尽可能的到它对应的node里面去找slab来进行分配。 也许在这个node里面别的CPU已经释放了一些slab，这样这个CPU就可以直接利用了，也不需要重新到伙伴系统里面去分配。</p>
<p>这也就是这两个结构里面都会有一些slab的原因。</p>
<ol class="arabic simple" start="2">
<li>struct kmem_cache_cpu</li>
</ol>
<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache_cpu</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">freelist</span><span class="p">;</span><span class="w">        </span><span class="cm">/* Pointer to next available object */</span>
<span class="w">                        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">tid</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Globally unique transaction id */</span>
<span class="w">                </span><span class="p">};</span>
<span class="w">                </span><span class="n">freelist_aba_t</span><span class="w"> </span><span class="n">freelist_tid</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">slab</span><span class="w"> </span><span class="o">*</span><span class="n">slab</span><span class="p">;</span><span class="w">      </span><span class="cm">/* The slab from which we are allocating */</span>
<span class="cp">#ifdef CONFIG_SLUB_CPU_PARTIAL</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">slab</span><span class="w"> </span><span class="o">*</span><span class="n">partial</span><span class="p">;</span><span class="w">   </span><span class="cm">/* Partially allocated slabs */</span>
<span class="cp">#endif</span>
<span class="w">        </span><span class="c1">//...</span>
<span class="p">};</span>
</pre></div>
<p>这里出现了一个freelist，这个是指向第一个free object的对应的指针。 这里把一个slab所对应的内存划分成很多个object，这些object就是最终要分配给上层软件的内存空间。在没有分配之前，这里会利用这个object所在的内存，存放next 指针，这个next 指针存放在这个object什么地方，由 struct kmem_cache的offset 来决定。这个offset一般放在这个object的中间，防止踩内存的出现，参考函数： calculate_sizes</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Store freelist pointer near middle of object to keep</span>
<span class="cm"> * it away from the edges of the object to avoid small</span>
<span class="cm"> * sized over/underflows from neighboring allocations.</span>
<span class="cm"> */</span>
<span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ALIGN_DOWN</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">object_size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">));</span>
</pre></div>
<p>tid在这里的作用是同步任务用的，如果当前任务分配内存分配到一半，被切换出去了，而前面计划分配给这个任务的内存，可能被别的内务给分配了，那这个时候就需要重新给这个任务分配。 参考函数： __slab_alloc_node：</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">__always_inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">__slab_alloc_node</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">,</span>
<span class="w">                </span><span class="n">gfp_t</span><span class="w"> </span><span class="n">gfpflags</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">orig_size</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="c1">//...</span>
<span class="nl">redo</span><span class="p">:</span>
<span class="w">        </span><span class="c1">//获取当前CPU的slab信息</span>
<span class="w">        </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">raw_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">);</span>
<span class="w">        </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">READ_ONCE</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">USE_LOCKLESS_FAST_PATH</span><span class="p">()</span><span class="w"> </span><span class="o">||</span>
<span class="w">            </span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">slab</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">node_match</span><span class="p">(</span><span class="n">slab</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">//Slow path里面会disable 任务迁移到别的CPU里面去</span>
<span class="w">                </span><span class="n">object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__slab_alloc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">gfpflags</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">orig_size</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">//如果发现这个tid和c-&gt;tid不一样，直接fail了重新做</span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">__update_cpu_freelist_fast</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="n">next_object</span><span class="p">,</span><span class="w"> </span><span class="n">tid</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                                </span><span class="n">note_cmpxchg_failure</span><span class="p">(</span><span class="s">&quot;slab_alloc&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">tid</span><span class="p">);</span>
<span class="w">                                </span><span class="k">goto</span><span class="w"> </span><span class="n">redo</span><span class="p">;</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">            </span><span class="c1">//..</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">__slab_alloc</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">gfp_t</span><span class="w"> </span><span class="n">gfpflags</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">node</span><span class="p">,</span>
<span class="w">                          </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache_cpu</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">orig_size</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PREEMPT_COUNT</span>
<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * We may have been preempted and rescheduled on a different</span>
<span class="cm">         * cpu before disabling preemption. Need to reload cpu area</span>
<span class="cm">         * pointer.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slub_get_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">);</span><span class="w">  </span><span class="c1">//disable 任务迁移到别的CPU</span>
<span class="cp">#endif</span>

<span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">___slab_alloc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">gfpflags</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">orig_size</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PREEMPT_COUNT</span>
<span class="w">        </span><span class="n">slub_put_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>字段slab 对应的就是当前被分配的slab，每次alloc 内存的时候，如果slab为空(第一次使用），或者freelist 为空（slab没有空闲的object)，那就需要先分配一个新的slab。</p>
<p>至于如何分配新的slab，这个首先要到partial列表里面去找对应的slab，如果还找不到，就到struct kmem_cache_node 的partial列表去找，如果还找不到，就到buddy里面去分配一个新的slab。</p>
<p>partial 就是一个slab的列表，因为系统内存会分配和释放同时进行，这样就会出现多个slab，部分有分配出去，部分是空闲的，这也就是这个字段partial的来源。</p>
<ol class="arabic simple" start="3">
<li>struct kmem_cache_node</li>
</ol>
<p>这个结构主要是维护统一个numa node里面被分配过的slab列表。当这个CPU的slab全都被分配出去之后，就可以考虑从这个node里面去找对应的slab，也许别的CPU释放了很多内存，最终被释放到numa node里面，这样就不需要到buddy里面去分配。</p>
<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache_node</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">spinlock_t</span><span class="w"> </span><span class="n">list_lock</span><span class="p">;</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">nr_partial</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">partial</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//....</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//..</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache_node</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
<p>kmem_cache 里面的node 是一个指针，所以也需要分配内存，这个也是一个专门的cache pool里面来分配的，具体看下面。</p>
</div>
<div class="section" id="section-2">
<h2>管理数据的创建</h2>
<p>在执行完mm_core_init -&gt; mem_init -&gt; memblock_free_all 之后，buddy系统就已经准备好了，可以进行以page为单位的内存分配。</p>
<p>mm_core_init -&gt; kmem_cache_init 就是创建struct kmem_cache  管理数据啦，在这之后就可以调用kmalloc来进行小块内存的分配和释放。</p>
<p>系统有：</p>
<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache</span><span class="w"> </span><span class="o">*</span><span class="n">kmem_cache</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache</span><span class="w"> </span><span class="o">*</span><span class="n">kmem_cache_node</span><span class="p">;</span>
</pre></div>
<p>系统里面可能会有很多的struct kmem_cache 和struct kmem_cache_node ，所以也需要为他们准备一个pool。 这两个pool就是为他们准备的，它们的初始化稍微有一点点不一样，可以参考函数 kmem_cache_init：</p>
<div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">kmem_cache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="n">__initdata</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache</span><span class="w"> </span><span class="n">boot_kmem_cache</span><span class="p">,</span>
<span class="w">                </span><span class="n">boot_kmem_cache_node</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">node</span><span class="p">;</span>

<span class="w">        </span><span class="c1">//不是很清楚为啥这里使用静态变量，感觉stack 变量应该也可以，后面在bootstrap的时候会copy到动态分配的变量里</span>
<span class="w">        </span><span class="n">kmem_cache_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">boot_kmem_cache_node</span><span class="p">;</span>
<span class="w">        </span><span class="n">kmem_cache</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">boot_kmem_cache</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * Initialize the nodemask for which we will allocate per node</span>
<span class="cm">         * structures. Here we don&#39;t need taking slab_mutex yet.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="n">for_each_node_state</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">N_NORMAL_MEMORY</span><span class="p">)</span>
<span class="w">                </span><span class="n">node_set</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">slab_nodes</span><span class="p">);</span>

<span class="w">        </span><span class="c1">//第一步就是创建struct kmem_cache_node的pool， 这个时候对应的struct kmem_cache-&gt;node就不能使用这个cache来分配，</span>
<span class="w">        </span><span class="c1">//而是要使用early_kmem_cache_node_alloc来分配，参看函数：init_kmem_cache_nodes</span>
<span class="w">        </span><span class="n">create_boot_cache</span><span class="p">(</span><span class="n">kmem_cache_node</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;kmem_cache_node&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache_node</span><span class="p">),</span><span class="w"> </span><span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">        </span><span class="n">hotplug_memory_notifier</span><span class="p">(</span><span class="n">slab_memory_callback</span><span class="p">,</span><span class="w"> </span><span class="n">SLAB_CALLBACK_PRI</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Able to allocate the per node structures */</span>
<span class="w">        </span><span class="n">slab_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PARTIAL</span><span class="p">;</span>

<span class="w">        </span><span class="c1">//第二步就是创建struct kmem_cache的pool，这个时候可以使用上面那个pool来分配这个对应的struct kmem_cache_node，这也就是上面那句slab_state = PARTIAL的原因</span>
<span class="w">        </span><span class="c1">//这个大小就是根据系统有多少node就分配多少，不需要分配所有的node的指针</span>
<span class="w">        </span><span class="n">create_boot_cache</span><span class="p">(</span><span class="n">kmem_cache</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;kmem_cache&quot;</span><span class="p">,</span>
<span class="w">                        </span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">                                </span><span class="n">nr_node_ids</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache_node</span><span class="w"> </span><span class="o">*</span><span class="p">),</span>
<span class="w">                       </span><span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">        </span><span class="c1">//前面不是使用静态变量来存放struct kmem_cache，这里重新在kmem_cache这个pool里面分配这个结构体，</span>
<span class="w">        </span><span class="c1">//再把想对应的信息复制过去，然后 struct kmem_cache boot_kmem_cache, boot_kmem_cache_node; 使命就完成</span>
<span class="w">        </span><span class="n">kmem_cache</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bootstrap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boot_kmem_cache</span><span class="p">);</span>
<span class="w">        </span><span class="n">kmem_cache_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bootstrap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boot_kmem_cache_node</span><span class="p">);</span>

<span class="w">        </span><span class="c1">//第三步，有了前面两步，那现在就可以直接使用上面两个pool来创建比的kmem_cache</span>
<span class="w">        </span><span class="c1">//下面这里就是创建一下基本大小的pool，如8，16，32等等</span>
<span class="w">        </span><span class="cm">/* Now we can use the kmem_cache to allocate kmalloc slabs */</span>
<span class="w">        </span><span class="n">setup_kmalloc_cache_index_table</span><span class="p">();</span>
<span class="w">        </span><span class="n">create_kmalloc_caches</span><span class="p">();</span>

<span class="w">        </span><span class="c1">//到这里之后，就可以开始使用kmalloc来分配内存了</span>
</pre></div>
<p>所有这些数据结构的创建过程，最终都是调用 __kmem_cache_create ，这个函数只是初始化一些管理的信息，而不会为这个创建的cache pool分配任何的slab。分配slab这个动作都是在分配内存的时候才会去做。</p>
<p>但是因为这里需要用到struct kmem_cache 和struct kmem_cache_node， 所有可能会在kmem_cache 和kmem_cache_node 这两个pool里面分配内存，这两个pool也就有可能会分配slab。这个上面那个原则不矛盾。 也就是使用pool来分配内存的时候才会分配对应的slab。</p>
<p>在create_kmalloc_cache 中会分配结构struct kmem_cache， 在init_kmem_cache_nodes 中分分配结构struct kmem_cache_node。 所以这两个函数都会为这两个pool分配slab</p>
</div>
<div class="section" id="section-3">
<h2>分配</h2>
<p>最终的分配都要到函数slab_alloc_node -&gt; __slab_alloc_node:</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">__always_inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">__slab_alloc_node</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">,</span>
<span class="w">                </span><span class="n">gfp_t</span><span class="w"> </span><span class="n">gfpflags</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">orig_size</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache_cpu</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">slab</span><span class="w"> </span><span class="o">*</span><span class="n">slab</span><span class="p">;</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">tid</span><span class="p">;</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">object</span><span class="p">;</span>

<span class="nl">redo</span><span class="p">:</span>
<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * Must read kmem_cache cpu data via this cpu ptr. Preemption is</span>
<span class="cm">         * enabled. We may switch back and forth between cpus while</span>
<span class="cm">         * reading from one cpu area. That does not matter as long</span>
<span class="cm">         * as we end up on the original cpu again when doing the cmpxchg.</span>
<span class="cm">         *</span>
<span class="cm">         * We must guarantee that tid and kmem_cache_cpu are retrieved on the</span>
<span class="cm">         * same cpu. We read first the kmem_cache_cpu pointer and use it to read</span>
<span class="cm">         * the tid. If we are preempted and switched to another cpu between the</span>
<span class="cm">         * two reads, it&#39;s OK as the two are still associated with the same cpu</span>
<span class="cm">         * and cmpxchg later will validate the cpu.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">raw_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">);</span>
<span class="w">        </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">READ_ONCE</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * Irqless object alloc/free algorithm used here depends on sequence</span>
<span class="cm">         * of fetching cpu_slab&#39;s data. tid should be fetched before anything</span>
<span class="cm">         * on c to guarantee that object and slab associated with previous tid</span>
<span class="cm">         * won&#39;t be used with current tid. If we fetch tid first, object and</span>
<span class="cm">         * slab could be one associated with next tid and our alloc/free</span>
<span class="cm">         * request will be failed. In this case, we will retry. So, no problem.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="n">barrier</span><span class="p">();</span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * The transaction ids are globally unique per cpu and per operation on</span>
<span class="cm">         * a per cpu queue. Thus they can be guarantee that the cmpxchg_double</span>
<span class="cm">         * occurs on the right processor and that there was no operation on the</span>
<span class="cm">         * linked list in between.</span>
<span class="cm">         */</span>

<span class="w">        </span><span class="n">object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
<span class="w">        </span><span class="n">slab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">USE_LOCKLESS_FAST_PATH</span><span class="p">()</span><span class="w"> </span><span class="o">||</span>
<span class="w">            </span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">slab</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">node_match</span><span class="p">(</span><span class="n">slab</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__slab_alloc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">gfpflags</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">orig_size</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">next_object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_freepointer_safe</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">object</span><span class="p">);</span>

<span class="w">                </span><span class="cm">/*</span>
<span class="cm">                 * The cmpxchg will only match if there was no additional</span>
<span class="cm">                 * operation and if we are on the right processor.</span>
<span class="cm">                 *</span>
<span class="cm">                 * The cmpxchg does the following atomically (without lock</span>
<span class="cm">                 * semantics!)</span>
<span class="cm">                 * 1. Relocate first pointer to the current per cpu area.</span>
<span class="cm">                 * 2. Verify that tid and freelist have not been changed</span>
<span class="cm">                 * 3. If they were not changed replace tid and freelist</span>
<span class="cm">                 *</span>
<span class="cm">                 * Since this is without lock semantics the protection is only</span>
<span class="cm">                 * against code executing on this cpu *not* from access by</span>
<span class="cm">                 * other cpus.</span>
<span class="cm">                 */</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">__update_cpu_freelist_fast</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="n">next_object</span><span class="p">,</span><span class="w"> </span><span class="n">tid</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="n">note_cmpxchg_failure</span><span class="p">(</span><span class="s">&quot;slab_alloc&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">tid</span><span class="p">);</span>
<span class="w">                        </span><span class="k">goto</span><span class="w"> </span><span class="n">redo</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="n">prefetch_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">next_object</span><span class="p">);</span>
<span class="w">                </span><span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ALLOC_FASTPATH</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">object</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>那个redo的原因，前面也解释过了，注释也是比较清楚的。 在slow path的时候，函数__slab_alloc 中会禁止把任务调度到别的CPU上去。</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">__slab_alloc</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">gfp_t</span><span class="w"> </span><span class="n">gfpflags</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">node</span><span class="p">,</span>
<span class="w">                          </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache_cpu</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">orig_size</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PREEMPT_COUNT</span>
<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * We may have been preempted and rescheduled on a different</span>
<span class="cm">         * cpu before disabling preemption. Need to reload cpu area</span>
<span class="cm">         * pointer.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slub_get_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">);</span><span class="w"> </span><span class="c1">//禁止把任务调度到别的CPU上去</span>
<span class="cp">#endif</span>

<span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">___slab_alloc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">gfpflags</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">orig_size</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PREEMPT_COUNT</span>
<span class="w">        </span><span class="n">slub_put_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>在slow path的___slab_alloc里面，逻辑稍微复杂一点，其实就是什么时候在CPU slab里面直接分配，什么时候去CPU partial里面分配，什么时候去node里面分配，什么时候去buddy里面去分配。</p>
</div>
<div class="section" id="section-4">
<h2>释放</h2>
<p>释放最终都会调用到函数： slab_free -&gt; do_slab_free ,如果free 的object 是在当前CPU的slab上，则直接设置kmem_cache_cpu 的freelist,如果不在当前CPU的slab上，则调用__slab_free。</p>
<p>第一步，更新当前slab的信息，就是把要free的object 放到slab的freelist 里来。</p>
<div class="highlight"><pre><span></span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="w">                </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">prior</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slab</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
<span class="w">        </span><span class="n">counters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slab</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">;</span>
<span class="w">        </span><span class="n">set_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="p">,</span><span class="w"> </span><span class="n">prior</span><span class="p">);</span>
<span class="w">        </span><span class="n">new</span><span class="p">.</span><span class="n">counters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counters</span><span class="p">;</span>
<span class="w">        </span><span class="n">was_frozen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="p">.</span><span class="n">frozen</span><span class="p">;</span>
<span class="w">        </span><span class="n">new</span><span class="p">.</span><span class="n">inuse</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">cnt</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="o">!</span><span class="n">new</span><span class="p">.</span><span class="n">inuse</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">prior</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">was_frozen</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* Needs to be taken off a list */</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">kmem_cache_has_cpu_partial</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">prior</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">                        </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">slab_nid</span><span class="p">(</span><span class="n">slab</span><span class="p">));</span>
<span class="w">                        </span><span class="cm">/*</span>
<span class="cm">                         * Speculatively acquire the list_lock.</span>
<span class="cm">                         * If the cmpxchg does not succeed then we may</span>
<span class="cm">                         * drop the list_lock without any processing.</span>
<span class="cm">                         *</span>
<span class="cm">                         * Otherwise the list_lock will synchronize with</span>
<span class="cm">                         * other processors updating the list of slabs.</span>
<span class="cm">                         */</span>
<span class="w">                        </span><span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>

<span class="w">                        </span><span class="n">on_node_partial</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slab_test_node_partial</span><span class="p">(</span><span class="n">slab</span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">slab_update_freelist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">slab</span><span class="p">,</span>
<span class="w">        </span><span class="n">prior</span><span class="p">,</span><span class="w"> </span><span class="n">counters</span><span class="p">,</span>
<span class="w">        </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">new</span><span class="p">.</span><span class="n">counters</span><span class="p">,</span>
<span class="w">        </span><span class="s">&quot;__slab_free&quot;</span><span class="p">));</span>
</pre></div>
<p>第二步，如果free之前，这个slab是完整被分配出去的，就把这个slab 挂到CPU 的partial list 里来，就结束。</p>
<div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">was_frozen</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/*</span>
<span class="cm">                 * The list lock was not taken therefore no list</span>
<span class="cm">                 * activity can be necessary.</span>
<span class="cm">                 */</span>
<span class="w">                </span><span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">FREE_FROZEN</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">kmem_cache_has_cpu_partial</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">prior</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/*</span>
<span class="cm">                 * If we started with a full slab then put it onto the</span>
<span class="cm">                 * per cpu partial list.</span>
<span class="cm">                 */</span>
<span class="w">                </span><span class="n">put_cpu_partial</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">slab</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">                </span><span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">CPU_PARTIAL_FREE</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>第三步，如果free 之后，这个slab变成了所有objects都是free状态的情况，这个时候就考虑这个node 里面的partial slab 的数量是不是大于最小值，大于就调用discard_slab回收这个slab。</p>
<div class="highlight"><pre><span></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">.</span><span class="n">inuse</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_partial</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">min_partial</span><span class="p">))</span>
<span class="w">                </span><span class="k">goto</span><span class="w"> </span><span class="n">slab_empty</span><span class="p">;</span>

<span class="w">        </span><span class="c1">//...</span>

<span class="nl">slab_empty</span><span class="p">:</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prior</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/*</span>
<span class="cm">                 * Slab on the partial list.</span>
<span class="cm">                 */</span>
<span class="w">                </span><span class="n">remove_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">slab</span><span class="p">);</span>
<span class="w">                </span><span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">FREE_REMOVE_PARTIAL</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="w">        </span><span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">FREE_SLAB</span><span class="p">);</span>
<span class="w">        </span><span class="n">discard_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">slab</span><span class="p">);</span>
</pre></div>
<p>第四步，如果free之前，这个slab是完整被分配出去的，在free 一个object 之后，就可以把他加回node 的partial list：</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Objects left in the slab. If it was not on the partial list before</span>
<span class="cm"> * then add it.</span>
<span class="cm"> */</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">kmem_cache_has_cpu_partial</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">prior</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">add_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">slab</span><span class="p">,</span><span class="w"> </span><span class="n">DEACTIVATE_TO_TAIL</span><span class="p">);</span>
<span class="w">        </span><span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">FREE_ADD_PARTIAL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="k">return</span><span class="p">;</span>
</pre></div>
</div>
<p><a href="https://geesun.github.io/posts/2024/06/slub_alloc.html#disqus_thread">comments</a></p>                </article>
            </aside><!-- /#featured -->
                <section id="content" class="body">
                    <h1>Other articles</h1>
                    <ol id="posts-list" class="hfeed">

            <li><article class="hentry">
                <header>
                    <h1><a href="../posts/2024/06/kmem_cache.html" rel="bookmark"
                           title="Permalink to kmem_cache内存池使用">kmem_cache内存池使用</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <span>日 23 六月 2024</span>
<span>| tags: <a href="../tag/linux.html">Linux</a><a href="../tag/mmu.html">MMU</a><a href="../tag/slub.html">SLUB</a></span>
</footer><!-- /.post-info -->                <p>kmem_cache 作为一个基本的 allocator 组件，这里可以把他理解为用于某个特定大小的内存对象池。</p>
<p>Linux 系统中本身也存在很多这样的内存 …</p>
                <a class="readmore" href="../posts/2024/06/kmem_cache.html">read more</a>
<p><a href="https://geesun.github.io/posts/2024/06/kmem_cache.html#disqus_thread">comments</a></p>                </div><!-- /.entry-content -->
            </article></li>
            </ol><!-- /#posts-list -->
<nav>
  <ul>
    <li>Page 1 / 1</li>
  </ul>
</nav>
            </section><!-- /#content -->

        <footer id="contentinfo" class="body">
                <p>&copy; 2024 Qixiang Xu</p>
        </footer><!-- /#contentinfo -->

<script type="text/javascript">
    var disqus_shortname = 'geesun';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>