<!DOCTYPE html>
<html lang="cn">
<head>
        <meta charset="utf-8" />
        <title>Linux学习笔记 - vmalloc</title>
        <link rel="stylesheet" href="../theme/css/main.css" />

        <!--[if IE]>
            <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="../">Linux学习笔记 </a></h1>
                <nav><ul>
                    <li><a href="../category/linux.html">Linux</a></li>
                </ul>
                </nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="../posts/2024/06/vmalloc.html">vmalloc的理解</a></h1>
<footer class="post-info">
        <span>四 27 六月 2024</span>
<span>| tags: <a href="../tag/linux.html">Linux</a><a href="../tag/mmu.html">MMU</a><a href="../tag/vmalloc.html">vmalloc</a></span>
</footer><!-- /.post-info --><p>kmalloc 是分配的物理地址是连续的，如果系统中需要分配大块的内存，这个时候使用kmalloc可能就不一定能分配到连续的物理内存，这个时候就需要使用vmalloc。</p>
<blockquote>
可以参考kmalloc的实现，如果要分配大小大于 KMALLOC_MAX_CACHE_SIZE 的内存，系统不再使用slab来进行分配，而是使用__kmalloc_large_node。 这个时候其实就是使用        struct folio 来记录分配的。</blockquote>
<p>vmalloc的作用就是分配大块内存，这个大块内存是从虚拟地址的角度看的，而实际的对应的物理地址，可能是一些不连续的page组成的。 所以vmalloc主要是对虚拟地址进行管理，它物理地址的分配使用的就是buddy系统来分配一些pages：</p>
<p>可以看到arm64的linux 的内存布局里面有一大块就是给vmalloc来使用的：</p>
<div class="highlight"><pre><span></span><span class="w"> </span>Start<span class="w">                 </span>End<span class="w">                     </span>Size<span class="w">            </span>Use
<span class="w"> </span>-----------------------------------------------------------------------
<span class="w"> </span><span class="m">0000000000000000</span><span class="w">      </span>0000ffffffffffff<span class="w">         </span>256TB<span class="w">          </span>user
<span class="w"> </span>ffff000000000000<span class="w">      </span>ffff7fffffffffff<span class="w">         </span>128TB<span class="w">          </span>kernel<span class="w"> </span>logical<span class="w"> </span>memory<span class="w"> </span>map
<span class="o">[</span>ffff600000000000<span class="w">      </span>ffff7fffffffffff<span class="o">]</span><span class="w">         </span>32TB<span class="w">          </span><span class="o">[</span>kasan<span class="w"> </span>shadow<span class="w"> </span>region<span class="o">]</span>
<span class="w"> </span>ffff800000000000<span class="w">      </span>ffff80007fffffff<span class="w">           </span>2GB<span class="w">          </span>modules
<span class="w"> </span>ffff800080000000<span class="w">      </span>fffffbffefffffff<span class="w">         </span>124TB<span class="w">          </span>vmalloc
<span class="w"> </span>fffffbfff0000000<span class="w">      </span>fffffbfffdffffff<span class="w">         </span>224MB<span class="w">          </span>fixed<span class="w"> </span>mappings<span class="w"> </span><span class="o">(</span>top<span class="w"> </span>down<span class="o">)</span>
<span class="w"> </span>fffffbfffe000000<span class="w">      </span>fffffbfffe7fffff<span class="w">           </span>8MB<span class="w">          </span><span class="o">[</span>guard<span class="w"> </span>region<span class="o">]</span>
<span class="w"> </span>fffffbfffe800000<span class="w">      </span>fffffbffff7fffff<span class="w">          </span>16MB<span class="w">          </span>PCI<span class="w"> </span>I/O<span class="w"> </span>space
<span class="w"> </span>fffffbffff800000<span class="w">      </span>fffffbffffffffff<span class="w">           </span>8MB<span class="w">          </span><span class="o">[</span>guard<span class="w"> </span>region<span class="o">]</span>
<span class="w"> </span>fffffc0000000000<span class="w">      </span>fffffdffffffffff<span class="w">           </span>2TB<span class="w">          </span>vmemmap
<span class="w"> </span>fffffe0000000000<span class="w">      </span>ffffffffffffffff<span class="w">           </span>2TB<span class="w">          </span><span class="o">[</span>guard<span class="w"> </span>region<span class="o">]</span>
</pre></div>
<p>同时也可以看到kernel整个运行的虚拟地址也是在vmalloc区域， 参考：</p>
<div class="highlight"><pre><span></span><span class="cp">#define KIMAGE_VADDR            (MODULES_END)</span>
<span class="cp">#define VMALLOC_START           (MODULES_END)</span>
</pre></div>
<p>所以kernel 所在image的虚拟地址也是要纳入vmalloc来进行管理。 下面会有提到。</p>
<div class="section" id="section-1">
<h2>关键数据结构</h2>
<p>虚拟地址的管理分两部分，一部分是空闲虚拟地址的管理，另外一部分就是正在使用的虚拟地址的管理。</p>
<p>空闲虚拟地址有两个关键数据结构，一个是free_vmap_area_root 所指向的红黑树，另外一个就是free_vmap_area_list所指的双向链表。</p>
<p>这两个数据结构的节点都是struct vmap_area， 也就是对应的如下两个字段：</p>
<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">vmap_area</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//....</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">rb_node</span><span class="w"> </span><span class="n">rb_node</span><span class="p">;</span><span class="w">         </span><span class="cm">/* address sorted rbtree */</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">list</span><span class="p">;</span><span class="w">          </span><span class="cm">/* address sorted list */</span>
<span class="w">        </span><span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
<p>为什么需要这两个数据结构， free_vmap_area_root用来在分配的时候快速找到满足大小的可用虚拟地址.  free_vmap_area_list是在需要把两个相邻区域合并的时候，使用这个free_vmap_area_list 就比较方便的找到他们相邻的节点，方便快速合并。 可以参考代码:</p>
<blockquote>
purge_vmap_node-&gt; reclaim_list_global -&gt; merge_or_add_vmap_area_augment</blockquote>
<p>另一个就是分配出去的虚拟地址的管理，这个的关键的管理数据结构就是 static struct vmap_node *vmap_nodes。</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">vmap_node</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Simple size segregated storage. */</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">vmap_pool</span><span class="w"> </span><span class="n">pool</span><span class="p">[</span><span class="n">MAX_VA_SIZE_PAGES</span><span class="p">];</span>
<span class="w">        </span><span class="n">spinlock_t</span><span class="w"> </span><span class="n">pool_lock</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">skip_populate</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* Bookkeeping data of this node. */</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">rb_list</span><span class="w"> </span><span class="n">busy</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">rb_list</span><span class="w"> </span><span class="n">lazy</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * Ready-to-free areas.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">purge_list</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">work_struct</span><span class="w"> </span><span class="n">purge_work</span><span class="p">;</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">nr_purged</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">single</span><span class="p">;</span>
</pre></div>
<ul class="simple">
<li>struct rb_list busy  是一个红黑树，来记录哪些struct vmap_area 被分配出去了。它对应的节点就是struct vmap_area。</li>
<li>struct rb_list lazy; 也是一个红黑树，来记录被释放的struct vmap_area  还没有被放入到空闲列表里面的。 这个目的就是加快释放，只有在满足一定条件的时候（nr_lazy &gt; nr_lazy_max），才需要启动work queue（drain_vmap_work）来把这个lazy表里面的节点回收到空闲列表里去。 而下面的purge_list purge_work nr_purged 就是为了回收这个lazy list 而要使用的数据结构。 后面回收过程会详细记录。</li>
<li>struct vmap_pool pool 相关的几个字段就是建立一个1-MAX_VA_SIZE_PAGES个Page 的虚拟地址pool， 在回收的时候不是立即放到全局的free list， 先放到这个pool里面。 分配的时候也是先看下这个pool 里面有没有，优先到这个pool里分配。</li>
</ul>
<p>vmap_nodes 也是一个数组，这里是把整个虚拟地址空间打散，每 16个pages放在一个vmap_nodes 中。 比如系统有三个vmap_nodes， 第1-16个 page 放在vmap_nodes[0], 第17-32个page 放在vmap_nodes[1]，第33-48个page放在vmap_nodes[2] ，第49-64个page放在vmap_nodes[0]，一次类推。 这样做的好处是提高并行性。 并且现在的系统都是多CPU的，所以这个vmap_nodes的个数是跟cpu的个数相关的，参考函数：</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">vmap_init_nodes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">vmap_node</span><span class="w"> </span><span class="o">*</span><span class="n">vn</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>

<span class="cp">#if BITS_PER_LONG == 64</span>
<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * A high threshold of max nodes is fixed and bound to 128,</span>
<span class="cm">         * thus a scale factor is 1 for systems where number of cores</span>
<span class="cm">         * are less or equal to specified threshold.</span>
<span class="cm">         *</span>
<span class="cm">         * As for NUMA-aware notes. For bigger systems, for example</span>
<span class="cm">         * NUMA with multi-sockets, where we can end-up with thousands</span>
<span class="cm">         * of cores in total, a &quot;sub-numa-clustering&quot; should be added.</span>
<span class="cm">         *</span>
<span class="cm">         * In this case a NUMA domain is considered as a single entity</span>
<span class="cm">         * with dedicated sub-nodes in it which describe one group or</span>
<span class="cm">         * set of cores. Therefore a per-domain purging is supposed to</span>
<span class="cm">         * be added as well as a per-domain balancing.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clamp_t</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">num_possible_cpus</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">vn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmalloc_array</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vn</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_NOWAIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">__GFP_NOWARN</span><span class="p">);</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vn</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="cm">/* Node partition is 16 pages. */</span>
<span class="w">                        </span><span class="n">vmap_zone_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="p">;</span>
<span class="w">                        </span><span class="n">nr_vmap_nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">                        </span><span class="n">vmap_nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vn</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed to allocate an array. Disable a node layer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
</pre></div>
</div>
<div class="section" id="section-2">
<h2>初始化</h2>
<p>前面有提到kernel image本身运行的虚拟地址也是在这个vmalloc 的区域，在kernel 启动的阶段，这里定义了一个struct vm_struct 的的list来记录哪些VA地址空间已经被使用了。</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">vm_struct</span><span class="w"> </span><span class="o">*</span><span class="n">vmlist</span><span class="w"> </span><span class="n">__initdata</span><span class="p">;</span>
</pre></div>
<p>可以看到，在建立kernel页表的时候，会调用 paging_init -&gt; declare_kernel_vmas -&gt; declare_vma -&gt; vm_area_add_early 把kernel使用过的空间放到vmlist 中。</p>
<p>当vmalloc_init 初始化的时候，会首先将这部分虚拟地址放入到 vmap_nodes中对应的busy 树里面去。</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Setup nodes before importing vmlist.</span>
<span class="cm"> */</span>
<span class="n">vmap_init_nodes</span><span class="p">();</span>

<span class="cm">/* Import existing vmlist entries. */</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vmlist</span><span class="p">;</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">va</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">vmap_area_cachep</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_NOWAIT</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">va</span><span class="p">))</span>
<span class="w">                </span><span class="k">continue</span><span class="p">;</span>

<span class="w">        </span><span class="n">va</span><span class="o">-&gt;</span><span class="n">va_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
<span class="w">        </span><span class="n">va</span><span class="o">-&gt;</span><span class="n">va_end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">va</span><span class="o">-&gt;</span><span class="n">va_start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
<span class="w">        </span><span class="n">va</span><span class="o">-&gt;</span><span class="n">vm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>

<span class="w">        </span><span class="n">vn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addr_to_node</span><span class="p">(</span><span class="n">va</span><span class="o">-&gt;</span><span class="n">va_start</span><span class="p">);</span>
<span class="w">        </span><span class="n">insert_vmap_area</span><span class="p">(</span><span class="n">va</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">.</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">.</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>然后根据这些使用的va地址列表vmlist，建立free_vmap_area_root 和free_vmap_area_list，参考函数： vmalloc_init-&gt; vmap_init_free_space 。</p>
<p>这里会使用：</p>
<div class="highlight"><pre><span></span><span class="n">vmap_area_cachep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">vmap_area</span><span class="p">,</span><span class="w"> </span><span class="n">SLAB_PANIC</span><span class="p">);</span>
</pre></div>
<p>来建立 slub cache pool，然后vmap_area 都是在这个cache pool里面来分配，加快分配速度。</p>
</div>
<div class="section" id="section-3">
<h2>内存分配</h2>
<p>所有分配函数最后都是调用 __vmalloc_node_range 来进行实际的虚拟地址和物理page的分配。</p>
<div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">__vmalloc_node_range</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">align</span><span class="p">,</span>
<span class="w">                        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">gfp_t</span><span class="w"> </span><span class="n">gfp_mask</span><span class="p">,</span>
<span class="w">                        </span><span class="n">pgprot_t</span><span class="w"> </span><span class="n">prot</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">vm_flags</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">node</span><span class="p">,</span>
<span class="w">                        </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="c1">//分配虚拟地址</span>
<span class="w">        </span><span class="n">area</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__get_vm_area_node</span><span class="p">(</span><span class="n">real_size</span><span class="p">,</span><span class="w"> </span><span class="n">align</span><span class="p">,</span><span class="w"> </span><span class="n">shift</span><span class="p">,</span><span class="w"> </span><span class="n">VM_ALLOC</span><span class="w"> </span><span class="o">|</span>
<span class="w">                                  </span><span class="n">VM_UNINITIALIZED</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">vm_flags</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">,</span>
<span class="w">                                  </span><span class="n">gfp_mask</span><span class="p">,</span><span class="w"> </span><span class="n">caller</span><span class="p">);</span>


<span class="w">        </span><span class="c1">//分配物理page，并且把这个page和VA在MMU页表里面给对应起来</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__vmalloc_area_node</span><span class="p">(</span><span class="n">area</span><span class="p">,</span><span class="w"> </span><span class="n">gfp_mask</span><span class="p">,</span><span class="w"> </span><span class="n">prot</span><span class="p">,</span><span class="w"> </span><span class="n">shift</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">);</span>

<span class="p">}</span>
</pre></div>
<p>先看__get_vm_area_node -&gt; alloc_vmap_area</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">vmap_area</span><span class="w"> </span><span class="o">*</span><span class="n">alloc_vmap_area</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                                </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">align</span><span class="p">,</span>
<span class="w">                                </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">vstart</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">vend</span><span class="p">,</span>
<span class="w">                                </span><span class="kt">int</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">gfp_t</span><span class="w"> </span><span class="n">gfp_mask</span><span class="p">,</span>
<span class="w">                                </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">va_flags</span><span class="p">)</span>
<span class="p">{</span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * If a VA is obtained from a global heap(if it fails here)</span>
<span class="cm">         * it is anyway marked with this &quot;vn_id&quot; so it is returned</span>
<span class="cm">         * to this pool&#39;s node later. Such way gives a possibility</span>
<span class="cm">         * to populate pools based on users demand.</span>
<span class="cm">         *</span>
<span class="cm">         * On success a ready to go VA is returned.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="c1">// 首先尝试到vmap_node 的vmap_pool里面去分配（node_pool_del_va）</span>
<span class="w">        </span><span class="c1">// 并且如果是VMALLOC_START-END的地址，就设置vn_id，</span>
<span class="w">        </span><span class="c1">// 后面释放的时候就直接当道vmap_pool中，不直接放入global free list 中</span>
<span class="w">        </span><span class="n">va</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node_alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">align</span><span class="p">,</span><span class="w"> </span><span class="n">vstart</span><span class="p">,</span><span class="w"> </span><span class="n">vend</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vn_id</span><span class="p">);</span>


<span class="nl">retry</span><span class="p">:</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">addr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">vend</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">//如果上面的没有分配成功，就到全局的free list里面去分配。</span>
<span class="w">                </span><span class="n">preload_this_cpu_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_vmap_area_lock</span><span class="p">,</span><span class="w"> </span><span class="n">gfp_mask</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">);</span>
<span class="w">                </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__alloc_vmap_area</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_vmap_area_root</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">free_vmap_area_list</span><span class="p">,</span>
<span class="w">                        </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">align</span><span class="p">,</span><span class="w"> </span><span class="n">vstart</span><span class="p">,</span><span class="w"> </span><span class="n">vend</span><span class="p">);</span>
<span class="w">                </span><span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_vmap_area_lock</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">//分配成功之后，再把这个va插入到vmap_node 的对应的busy树里面</span>
<span class="w">        </span><span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">        </span><span class="n">insert_vmap_area</span><span class="p">(</span><span class="n">va</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">.</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">.</span><span class="n">head</span><span class="p">);</span>
<span class="w">        </span><span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">va</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>执行完上面的步骤之后，vmap_area 就跟一个分配的vm_struct 给对应起来了。
通过上面的步骤，已经找到满足要求的虚拟地址，接下来就是给他们分配物理地址，这个时候不是必须连续的。 因为只有vm_struct 里面才有物理地址的信息。</p>
<p>在函数__vmalloc_area_node -&gt; vm_area_alloc_pages 会去buddy系统里面去申请真正的物理内存。</p>
<p>在分配好了物理内存之后，就需要把VA和这些分配的page给对应起来。参考函数：</p>
<blockquote>
__vmalloc_area_node-&gt; vmap_pages_range  -&gt; vmap_pages_range_noflush -&gt; __vmap_pages_range_noflush -&gt; vmap_range_noflush</blockquote>
</div>
<div class="section" id="section-4">
<h2>内存释放</h2>
<p>释放的流程大概是调用remove_vm_area 从前面讲的vmap_nodes中对应的busy list 里面删除，然后再调用__free_page 回收到buddy 系统里面去。</p>
<div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vfree</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>

<span class="w">        </span><span class="c1">// 在中断中，调用vfree_deferred 的workqueue来进行回收，在workqueue里面再调用vfree函数进行回收。 本质是一样的。</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">vfree_atomic</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="w">                </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">//从vmap_nodes中对应的busy list 里面删除， 且会清除MMU页表</span>
<span class="w">        </span><span class="n">vm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remove_vm_area</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">vm</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">KERN_ERR</span><span class="w"> </span><span class="s">&quot;Trying to vfree() nonexistent vm area (%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">                                </span><span class="n">addr</span><span class="p">);</span>
<span class="w">                </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">vm</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">//回收到buddy系统中</span>
<span class="w">                </span><span class="n">__free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="w">                </span><span class="n">cond_resched</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="p">}</span>
</pre></div>
<p>在remove_vm_area -&gt; find_unlink_vmap_area 会在addr 对应的vmap_node中找到vmap_area 并且会把它从busy list里面删去。</p>
<p>在remove_vm_area-&gt; free_unmap_vmap_area-&gt; vunmap_range_noflush -&gt;__vunmap_range_noflush 里面修改对应的MMU页表，删除对应的页表项。</p>
<p>在函数remove_vm_area -&gt; free_unmap_vmap_area -&gt; free_vmap_area_noflush -&gt; insert_vmap_area 把对应的vmap_area 插入到vmap_node 的lazy队列。根据lazy队列的情况启动workqueue来回收虚拟地址：</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">free_vmap_area_noflush</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">vmap_area</span><span class="w"> </span><span class="o">*</span><span class="n">va</span><span class="p">)</span>
<span class="p">{</span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * If it was request by a certain node we would like to</span>
<span class="cm">         * return it to that node, i.e. its pool for later reuse.</span>
<span class="cm">         */</span>
<span class="w">         </span><span class="c1">//这里的代码和函数node_alloc 里面对应</span>
<span class="w">        </span><span class="n">vn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">is_vn_id_valid</span><span class="p">(</span><span class="n">vn_id</span><span class="p">)</span><span class="w"> </span><span class="o">?</span>
<span class="w">                </span><span class="n">id_to_node</span><span class="p">(</span><span class="n">vn_id</span><span class="p">)</span><span class="o">:</span><span class="n">addr_to_node</span><span class="p">(</span><span class="n">va</span><span class="o">-&gt;</span><span class="n">va_start</span><span class="p">);</span>

<span class="w">        </span><span class="c1">//放入lazy树中</span>
<span class="w">        </span><span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">lazy</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">        </span><span class="n">insert_vmap_area</span><span class="p">(</span><span class="n">va</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">lazy</span><span class="p">.</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">lazy</span><span class="p">.</span><span class="n">head</span><span class="p">);</span>
<span class="w">        </span><span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">lazy</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

<span class="w">        </span><span class="n">trace_free_vmap_area_noflush</span><span class="p">(</span><span class="n">va_start</span><span class="p">,</span><span class="w"> </span><span class="n">nr_lazy</span><span class="p">,</span><span class="w"> </span><span class="n">nr_lazy_max</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* After this point, we may free va at any time */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">nr_lazy</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">nr_lazy_max</span><span class="p">))</span>
<span class="w">                </span><span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drain_vmap_work</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>在workqueue 会运行函数__purge_vmap_area_lazy 这个函数首先会把vmap_node 中的lazy list 放入对应vmap_node 的purge_list：</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">__purge_vmap_area_lazy</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">end</span><span class="p">,</span>
<span class="w">                </span><span class="kt">bool</span><span class="w"> </span><span class="n">full_pool_decay</span><span class="p">)</span>
<span class="p">{</span>


<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nr_vmap_nodes</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">vn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vmap_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="w">                </span><span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">purge_list</span><span class="p">);</span>
<span class="w">                </span><span class="c1">//有可能vmap_node-&gt; pool 已经有很多空闲地址了，这里就是要把这个pool给缩小一下</span>
<span class="w">                </span><span class="c1">//如何full_pool_decay 为true就是全部清楚掉，再调用reclaim_list_global 放到global free list里面</span>
<span class="w">                </span><span class="n">decay_va_pool_node</span><span class="p">(</span><span class="n">vn</span><span class="p">,</span><span class="w"> </span><span class="n">full_pool_decay</span><span class="p">);</span>

<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">lazy</span><span class="p">.</span><span class="n">root</span><span class="p">))</span>
<span class="w">                        </span><span class="k">continue</span><span class="p">;</span>

<span class="w">                </span><span class="c1">//把lazy list 放入对应vmap_node 的purge_list</span>
<span class="w">                </span><span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">lazy</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">                </span><span class="n">WRITE_ONCE</span><span class="p">(</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">lazy</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="n">rb_node</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">                </span><span class="n">list_replace_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">lazy</span><span class="p">.</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">purge_list</span><span class="p">);</span>
<span class="w">                </span><span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">lazy</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
</pre></div>
<p>__purge_vmap_area_lazy接下来就是根据vn-&gt;purge_list来启动vn-&gt;purge_work 来工作：</p>
<div class="highlight"><pre><span></span><span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">purge_nodes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">vn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vmap_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nr_purge_helpers</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">purge_work</span><span class="p">,</span><span class="w"> </span><span class="n">purge_vmap_node</span><span class="p">);</span>

<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">cpu_online_mask</span><span class="p">))</span>
<span class="w">                        </span><span class="n">schedule_work_on</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">purge_work</span><span class="p">);</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                        </span><span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">purge_work</span><span class="p">);</span>

<span class="w">                </span><span class="n">nr_purge_helpers</span><span class="o">--</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">purge_work</span><span class="p">.</span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">                </span><span class="n">purge_vmap_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">purge_work</span><span class="p">);</span>
<span class="w">                </span><span class="n">nr_purged_areas</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">nr_purged</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>然后每个CPU执行函数 purge_vmap_node,在函数purge_vmap_node 中，会把回收的一些 vmap_area 放到vmap_node-&gt; pool 里面，以便可以快速的重新利用：</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">purge_vmap_node</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">work_struct</span><span class="w"> </span><span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">local_list</span><span class="p">);</span>

<span class="w">        </span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">nr_purged</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">        </span><span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">va</span><span class="p">,</span><span class="w"> </span><span class="n">n_va</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">purge_list</span><span class="p">,</span><span class="w"> </span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">va</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

<span class="w">                </span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">nr_purged</span><span class="o">++</span><span class="p">;</span>

<span class="w">                </span><span class="c1">//加入到vmap_node-&gt; pool</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_vn_id_valid</span><span class="p">(</span><span class="n">vn_id</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">vn</span><span class="o">-&gt;</span><span class="n">skip_populate</span><span class="p">)</span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node_pool_add_va</span><span class="p">(</span><span class="n">vn</span><span class="p">,</span><span class="w"> </span><span class="n">va</span><span class="p">))</span>
<span class="w">                                </span><span class="k">continue</span><span class="p">;</span>

<span class="w">                </span><span class="cm">/* Go back to global. */</span>
<span class="w">                </span><span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">va</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">local_list</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">//把这些要真正要回收的放入到free list中。</span>
<span class="w">        </span><span class="n">reclaim_list_global</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local_list</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>最后调用reclaim_list_global 放入全局的free_vmap_area_root中。</p>
</div>
<div class="section" id="section-5">
<h2>调试</h2>
<p>使用如下命令查看vmalloc的分配情况：</p>
<div class="highlight"><pre><span></span><span class="cp"># cat /proc/vmallocinfo</span>
<span class="mh">0xffff800080000000-0xffff800080005000</span><span class="w">   </span><span class="mi">20480</span><span class="w"> </span><span class="n">start_kernel</span><span class="o">+</span><span class="mh">0x258</span><span class="o">/</span><span class="mh">0x614</span><span class="w"> </span><span class="n">pages</span><span class="o">=</span><span class="mi">4</span><span class="w"> </span><span class="n">vmalloc</span><span class="w"> </span><span class="n">N0</span><span class="o">=</span><span class="mi">4</span>
<span class="mh">0xffff800080005000-0xffff800080007000</span><span class="w">    </span><span class="mi">8192</span><span class="w"> </span><span class="n">gen_pool_add_owner</span><span class="o">+</span><span class="mh">0x4c</span><span class="o">/</span><span class="mh">0xc4</span><span class="w"> </span><span class="n">pages</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="n">vmalloc</span><span class="w"> </span><span class="n">N0</span><span class="o">=</span><span class="mi">1</span>
<span class="mh">0xffff800080008000-0xffff80008000d000</span><span class="w">   </span><span class="mi">20480</span><span class="w"> </span><span class="n">start_kernel</span><span class="o">+</span><span class="mh">0x258</span><span class="o">/</span><span class="mh">0x614</span><span class="w"> </span><span class="n">pages</span><span class="o">=</span><span class="mi">4</span><span class="w"> </span><span class="n">vmalloc</span><span class="w"> </span><span class="n">N0</span><span class="o">=</span><span class="mi">4</span>
<span class="mh">0xffff80008000d000-0xffff80008000f000</span><span class="w">    </span><span class="mi">8192</span><span class="w"> </span><span class="n">gen_pool_add_owner</span><span class="o">+</span><span class="mh">0x4c</span><span class="o">/</span><span class="mh">0xc4</span><span class="w"> </span><span class="n">pages</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="n">vmalloc</span><span class="w"> </span><span class="n">N0</span><span class="o">=</span><span class="mi">1</span>
<span class="mh">0xffff800082b00000-0xffff800082b05000</span><span class="w">   </span><span class="mi">20480</span><span class="w"> </span><span class="n">kernel_clone</span><span class="o">+</span><span class="mh">0x68</span><span class="o">/</span><span class="mh">0x368</span><span class="w"> </span><span class="n">pages</span><span class="o">=</span><span class="mi">4</span><span class="w"> </span><span class="n">vmalloc</span><span class="w"> </span><span class="n">N0</span><span class="o">=</span><span class="mi">4</span>
<span class="mh">0xffff800082b0b000-0xffff800082b0d000</span><span class="w">    </span><span class="mi">8192</span><span class="w"> </span><span class="n">ioremap_prot</span><span class="o">+</span><span class="mh">0x50</span><span class="o">/</span><span class="mh">0x78</span><span class="w"> </span><span class="n">phys</span><span class="o">=</span><span class="mh">0x000000001c130000</span><span class="w"> </span><span class="n">ioremap</span>
<span class="mh">0xffff800082b0d000-0xffff800082b0f000</span><span class="w">    </span><span class="mi">8192</span><span class="w"> </span><span class="n">ioremap_prot</span><span class="o">+</span><span class="mh">0x50</span><span class="o">/</span><span class="mh">0x78</span><span class="w"> </span><span class="n">phys</span><span class="o">=</span><span class="mh">0x000000001c140000</span><span class="w"> </span><span class="n">ioremap</span>
<span class="mh">0xffff800082b80000-0xffff800082b85000</span><span class="w">   </span><span class="mi">20480</span><span class="w"> </span><span class="n">kernel_clone</span><span class="o">+</span><span class="mh">0x68</span><span class="o">/</span><span class="mh">0x368</span><span class="w"> </span><span class="n">pages</span><span class="o">=</span><span class="mi">4</span><span class="w"> </span><span class="n">vmalloc</span><span class="w"> </span><span class="n">N0</span><span class="o">=</span><span class="mi">4</span>
<span class="mh">0xffff800082b85000-0xffff800082b87000</span><span class="w">    </span><span class="mi">8192</span><span class="w"> </span><span class="n">ioremap_prot</span><span class="o">+</span><span class="mh">0x50</span><span class="o">/</span><span class="mh">0x78</span><span class="w"> </span><span class="n">phys</span><span class="o">=</span><span class="mh">0x000000005019e000</span><span class="w"> </span><span class="n">ioremap</span>
<span class="mh">0xffff800082b88000-0xffff800082b8d000</span><span class="w">   </span><span class="mi">20480</span><span class="w"> </span><span class="n">kernel_clone</span><span class="o">+</span><span class="mh">0x68</span><span class="o">/</span><span class="mh">0x368</span><span class="w"> </span><span class="n">pages</span><span class="o">=</span><span class="mi">4</span><span class="w"> </span><span class="n">vmalloc</span><span class="w"> </span><span class="n">N0</span><span class="o">=</span><span class="mi">4</span>
<span class="mh">0xffff800082b8d000-0xffff800082b8f000</span><span class="w">    </span><span class="mi">8192</span><span class="w"> </span><span class="n">ioremap_prot</span><span class="o">+</span><span class="mh">0x50</span><span class="o">/</span><span class="mh">0x78</span><span class="w"> </span><span class="n">phys</span><span class="o">=</span><span class="mh">0x0000000050008000</span><span class="w"> </span><span class="n">ioremap</span>
<span class="mh">0xffff800082c00000-0xffff800082e01000</span><span class="w"> </span><span class="mi">2101248</span><span class="w"> </span><span class="n">ioremap_prot</span><span class="o">+</span><span class="mh">0x50</span><span class="o">/</span><span class="mh">0x78</span><span class="w"> </span><span class="n">phys</span><span class="o">=</span><span class="mh">0x000000002f100000</span><span class="w"> </span><span class="n">ioremap</span>
<span class="mh">0xffff800082e02000-0xffff800082e05000</span><span class="w">   </span><span class="mi">12288</span><span class="w"> </span><span class="n">ioremap_prot</span><span class="o">+</span><span class="mh">0x50</span><span class="o">/</span><span class="mh">0x78</span><span class="w"> </span><span class="n">phys</span><span class="o">=</span><span class="mh">0x0000000050196000</span><span class="w"> </span><span class="n">ioremap</span>
<span class="mh">0xffff800082e08000-0xffff800082e0d000</span><span class="w">   </span><span class="mi">20480</span><span class="w"> </span><span class="n">kernel_clone</span><span class="o">+</span><span class="mh">0x68</span><span class="o">/</span><span class="mh">0x368</span><span class="w"> </span><span class="n">pages</span><span class="o">=</span><span class="mi">4</span><span class="w"> </span><span class="n">vmalloc</span><span class="w"> </span><span class="n">N0</span><span class="o">=</span><span class="mi">4</span>
<span class="mh">0xffff800082e80000-0xffff800082e85000</span><span class="w">   </span><span class="mi">20480</span><span class="w"> </span><span class="n">kernel_clone</span><span class="o">+</span><span class="mh">0x68</span><span class="o">/</span><span class="mh">0x368</span><span class="w"> </span><span class="n">pages</span><span class="o">=</span><span class="mi">4</span><span class="w"> </span><span class="n">vmalloc</span><span class="w"> </span><span class="n">N0</span><span class="o">=</span><span class="mi">4</span>
<span class="mh">0xffff800082e88000-0xffff800082e8d000</span><span class="w">   </span><span class="mi">20480</span><span class="w"> </span><span class="n">kernel_clone</span><span class="o">+</span><span class="mh">0x68</span><span class="o">/</span><span class="mh">0x368</span><span class="w"> </span><span class="n">pages</span><span class="o">=</span><span class="mi">4</span><span class="w"> </span><span class="n">vmalloc</span><span class="w"> </span><span class="n">N0</span><span class="o">=</span><span class="mi">4</span>
<span class="mh">0xffff800082f00000-0xffff800082f05000</span><span class="w">   </span><span class="mi">20480</span><span class="w"> </span><span class="n">kernel_clone</span><span class="o">+</span><span class="mh">0x68</span><span class="o">/</span><span class="mh">0x368</span><span class="w"> </span><span class="n">pages</span><span class="o">=</span><span class="mi">4</span><span class="w"> </span><span class="n">vmalloc</span><span class="w"> </span><span class="n">N0</span><span class="o">=</span><span class="mi">4</span>
<span class="mh">0xffff800082f08000-0xffff800082f0d000</span><span class="w">   </span><span class="mi">20480</span><span class="w"> </span><span class="n">kernel_clone</span><span class="o">+</span><span class="mh">0x68</span><span class="o">/</span><span class="mh">0x368</span><span class="w"> </span><span class="n">pages</span><span class="o">=</span><span class="mi">4</span><span class="w"> </span><span class="n">vmalloc</span><span class="w"> </span><span class="n">N0</span><span class="o">=</span><span class="mi">4</span>
<span class="mh">0xffff800083300000-0xffff800083305000</span><span class="w">   </span><span class="mi">20480</span><span class="w"> </span><span class="n">kernel_clone</span><span class="o">+</span><span class="mh">0x68</span><span class="o">/</span><span class="mh">0x368</span><span class="w"> </span><span class="n">pages</span><span class="o">=</span><span class="mi">4</span><span class="w"> </span><span class="n">vmalloc</span><span class="w"> </span><span class="n">N0</span><span class="o">=</span><span class="mi">4</span>
<span class="mh">0xffff800083308000-0xffff80008330d000</span><span class="w">   </span><span class="mi">20480</span><span class="w"> </span><span class="n">kernel_clone</span><span class="o">+</span><span class="mh">0x68</span><span class="o">/</span><span class="mh">0x368</span><span class="w"> </span><span class="n">pages</span><span class="o">=</span><span class="mi">4</span><span class="w"> </span><span class="n">vmalloc</span><span class="w"> </span><span class="n">N0</span><span class="o">=</span><span class="mi">4</span>
</pre></div>
</div>
<p><a href="https://geesun.github.io/posts/2024/06/vmalloc.html#disqus_thread">comments</a></p>                </article>
<nav>
  <ul>
    <li>Page 1 / 1</li>
  </ul>
</nav>
            </aside><!-- /#featured -->
            </ol><!-- /#posts-list -->
            </section><!-- /#content -->

        <footer id="contentinfo" class="body">
                <p>&copy; 2024 Qixiang Xu</p>
        </footer><!-- /#contentinfo -->

<script type="text/javascript">
    var disqus_shortname = 'geesun';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>