<!DOCTYPE html>
<html lang="cn">
<head>
        <meta charset="utf-8" />
        <title>Libev 学习笔记</title>
        <link rel="stylesheet" href="../../../theme/css/main.css" />
        <link href="https://geesun.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Geesun's Blog Atom Feed" />

        <!--[if IE]>
            <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="../../../">Geesun's Blog </a></h1>
                <nav><ul>
                    <li><a href="../../../category/leetcode.html">Leetcode</a></li>
                    <li class="active"><a href="../../../category/network.html">Network</a></li>
                </ul>
                </nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="../../../posts/2015/09/libev_note.html" rel="bookmark"
           title="Permalink to Libev 学习笔记">Libev 学习笔记</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <span>四 10 九月 2015</span>
<span>| tags: <a href="../../../tag/libev.html">libev</a></span>
</footer><!-- /.post-info -->      <p>Libev是一个用C编写的功能齐全的高性能的轻量级事件驱动库,作为Libevent的替代者，拥有更快的速度，更小的体积。</p>
<h3>安装Libev</h3>
<div class="highlight"><pre>sudo apt-get install libev-dev
</pre></div>


<p>Libev通过ev_loop结构来表示一个事件驱动的框架,在这个框架之下，支持几十种事件，每个事件通过ev_TYPE结构体，ev_TYEP_init,ev_TYPE_set,ev_TYPE_start,ev_TYPE_stop等API来跟这个事件框架注册事件监控器。当我们要监控的事件出现是，框架便会触发已经注册的时间监控器来处理事件。</p>
<h3>支持的事件类型</h3>
<div class="highlight"><pre><span class="n">ev_io</span>                 <span class="c1">// IO可读可写</span>
<span class="n">ev_timer</span>              <span class="c1">// 相对定时器</span>
<span class="n">ev_periodic</span>           <span class="c1">// 绝对定时器</span>
<span class="n">ev_signal</span>             <span class="c1">// 信号处理</span>
<span class="n">ev_child</span>              <span class="c1">// 子进程状态变化</span>
<span class="n">ev_stat</span>               <span class="c1">// 文件属性变化</span>
<span class="n">ev_idle</span>               <span class="c1">// event loop空闲触发事件</span>
<span class="n">ev_prepare</span>            <span class="c1">// event loop之前事件</span>
<span class="n">ev_check</span>              <span class="c1">// event loop之后事件</span>
<span class="n">ev_embed</span>              <span class="c1">// 嵌入另一个后台循环</span>
<span class="n">ev_fork</span>               <span class="c1">// fork事件</span>
<span class="n">ev_cleanup</span>            <span class="c1">// event loop退出触发事件</span>
<span class="n">ev_async</span>              <span class="c1">// 线程间异步事件</span>
</pre></div>


<h3>作者例子</h3>
<div class="highlight"><pre>man libev 
</pre></div>


<p>可以获得作者写的<a href="http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#EXAMPLE_PROGRAM">例子</a>
,并有详细解释。</p>
<div class="highlight"><pre><span class="c1">// a single header file is required</span>
<span class="cp">#include &lt;ev.h&gt;</span>

<span class="cp">#include &lt;stdio.h&gt; </span><span class="c1">// for puts</span>

<span class="c1">// every watcher type has its own typedef&#39;d struct</span>
<span class="c1">// with the name ev_TYPE</span>
<span class="n">ev_io</span> <span class="n">stdin_watcher</span><span class="p">;</span>
<span class="n">ev_timer</span> <span class="n">timeout_watcher</span><span class="p">;</span>

<span class="c1">// all watcher callbacks have a similar signature</span>
<span class="c1">// this callback is called when data is readable on stdin</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">stdin_cb</span> <span class="p">(</span><span class="n">EV_P_</span> <span class="n">ev_io</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">revents</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">puts</span> <span class="p">(</span><span class="s">&quot;stdin ready&quot;</span><span class="p">);</span>
    <span class="c1">// for one-shot events, one must manually stop the watcher</span>
    <span class="c1">// with its corresponding stop function.</span>
    <span class="n">ev_io_stop</span> <span class="p">(</span><span class="n">EV_A_</span> <span class="n">w</span><span class="p">);</span>

    <span class="c1">// this causes all nested ev_run&#39;s to stop iterating</span>
    <span class="n">ev_break</span> <span class="p">(</span><span class="n">EV_A_</span> <span class="n">EVBREAK_ALL</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// another callback, this time for a time-out</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">timeout_cb</span> <span class="p">(</span><span class="n">EV_P_</span> <span class="n">ev_timer</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">revents</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">puts</span> <span class="p">(</span><span class="s">&quot;timeout&quot;</span><span class="p">);</span>
    <span class="c1">// this causes the innermost ev_run to stop iterating</span>
    <span class="n">ev_break</span> <span class="p">(</span><span class="n">EV_A_</span> <span class="n">EVBREAK_ONE</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// use the default event loop unless you have special needs</span>
    <span class="k">struct</span> <span class="n">ev_loop</span> <span class="o">*</span><span class="n">loop</span> <span class="o">=</span> <span class="n">EV_DEFAULT</span><span class="p">;</span>

    <span class="c1">// initialise an io watcher, then start it</span>
    <span class="c1">// this one will watch for stdin to become readable</span>
    <span class="n">ev_io_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">stdin_watcher</span><span class="p">,</span> <span class="n">stdin_cb</span><span class="p">,</span> <span class="cm">/*STDIN_FILENO*/</span> <span class="mi">0</span><span class="p">,</span> <span class="n">EV_READ</span><span class="p">);</span>
    <span class="n">ev_io_start</span> <span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stdin_watcher</span><span class="p">);</span>

    <span class="c1">// initialise a timer watcher, then start it</span>
    <span class="c1">// simple non-repeating 5.5 second timeout</span>
    <span class="n">ev_timer_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">timeout_watcher</span><span class="p">,</span> <span class="n">timeout_cb</span><span class="p">,</span> <span class="mf">5.5</span><span class="p">,</span> <span class="mf">0.</span><span class="p">);</span>
    <span class="n">ev_timer_start</span> <span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeout_watcher</span><span class="p">);</span>

    <span class="c1">// now wait for events to arrive</span>
    <span class="n">ev_run</span> <span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// break was called, so exit</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>解释一下EV_P，EV_P_，EV_A，EV_A_这几个宏，在代码中会经常看到这几个宏，主要是为了简化单线程模式下的函数调用的接口，在Libev的源代码的ev.h中，有：</p>
<div class="highlight"><pre><span class="cm">/* support multiple event loops? */</span>
<span class="cp">#if EV_MULTIPLICITY</span>
<span class="k">struct</span> <span class="n">ev_loop</span><span class="p">;</span>
<span class="cp"># define EV_P  struct ev_loop *loop               </span><span class="cm">/* a loop as sole parameter in a declaration */</span><span class="cp"></span>
<span class="cp"># define EV_P_ EV_P,                              </span><span class="cm">/* a loop as first of multiple parameters */</span><span class="cp"></span>
<span class="cp"># define EV_A  loop                               </span><span class="cm">/* a loop as sole argument to a function call */</span><span class="cp"></span>
<span class="cp"># define EV_A_ EV_A,                              </span><span class="cm">/* a loop as first of multiple arguments */</span><span class="cp"></span>
<span class="cp"># define EV_DEFAULT_UC  ev_default_loop_uc_ ()    </span><span class="cm">/* the default loop, if initialised, as sole arg */</span><span class="cp"></span>
<span class="cp"># define EV_DEFAULT_UC_ EV_DEFAULT_UC,            </span><span class="cm">/* the default loop as first of multiple arguments */</span><span class="cp"></span>
<span class="cp"># define EV_DEFAULT  ev_default_loop (0)          </span><span class="cm">/* the default loop as sole arg */</span><span class="cp"></span>
<span class="cp"># define EV_DEFAULT_ EV_DEFAULT,                  </span><span class="cm">/* the default loop as first of multiple arguments */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp"># define EV_P void</span>
<span class="cp"># define EV_P_</span>
<span class="cp"># define EV_A</span>
<span class="cp"># define EV_A_</span>
<span class="cp"># define EV_DEFAULT</span>
<span class="cp"># define EV_DEFAULT_</span>
<span class="cp"># define EV_DEFAULT_UC</span>
<span class="cp"># define EV_DEFAULT_UC_</span>
<span class="cp"># undef EV_EMBED_ENABLE</span>
<span class="cp">#endif</span>
</pre></div>


<p>如果包含EV_MULTIPLICITY, 表示支持多个ev_loop实例存在，一般来说，一个线程中有且只有一个ev_loop实例。如果整个程序是单线程，程序中使用默认的ev_loop即可，即全局的ev_loop( 没有用结构)，所以不需要参数。
多实例和全局结构可以在 ev.c中找到。</p>
<div class="highlight"><pre><span class="cp">#if EV_MULTIPLICITY</span>

  <span class="k">struct</span> <span class="n">ev_loop</span>
  <span class="p">{</span>
    <span class="n">ev_tstamp</span> <span class="n">ev_rt_now</span><span class="p">;</span>
    <span class="cp">#define ev_rt_now ((loop)-&gt;ev_rt_now)</span>
    <span class="cp">#define VAR(name,decl) decl;</span>
      <span class="cp">#include &quot;ev_vars.h&quot;</span>
    <span class="cp">#undef VAR</span>
  <span class="p">};</span>
  <span class="cp">#include &quot;ev_wrap.h&quot;</span>

  <span class="k">static</span> <span class="k">struct</span> <span class="n">ev_loop</span> <span class="n">default_loop_struct</span><span class="p">;</span>
  <span class="n">EV_API_DECL</span> <span class="k">struct</span> <span class="n">ev_loop</span> <span class="o">*</span><span class="n">ev_default_loop_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* needs to be initialised to make it a definition despite extern */</span>

<span class="cp">#else</span>

  <span class="n">EV_API_DECL</span> <span class="n">ev_tstamp</span> <span class="n">ev_rt_now</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* needs to be initialised to make it a definition despite extern */</span>
  <span class="cp">#define VAR(name,decl) static decl;</span>
    <span class="cp">#include &quot;ev_vars.h&quot;</span>
  <span class="cp">#undef VAR</span>

  <span class="k">static</span> <span class="kt">int</span> <span class="n">ev_default_loop_ptr</span><span class="p">;</span>

<span class="cp">#endif</span>
</pre></div>


<h3>简单socket例子</h3>
<div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;errno.h&gt;</span>
<span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;netinet/in.h&gt;</span>
<span class="cp">#include &lt;sys/socket.h&gt;</span>
<span class="cp">#include &lt;ev.h&gt;</span>

<span class="cp">#define PORT 9000</span>
<span class="cp">#define IP &quot;127.0.0.1&quot;</span>

<span class="kt">int</span> <span class="nf">create_socket</span><span class="p">();</span> 
<span class="kt">void</span> <span class="nf">accept_socket_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ev_loop</span> <span class="o">*</span><span class="n">loop</span><span class="p">,</span><span class="n">ev_io</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">revents</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">recv_socket_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ev_loop</span> <span class="o">*</span><span class="n">loop</span><span class="p">,</span><span class="n">ev_io</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">revents</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">write_socket_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ev_loop</span> <span class="o">*</span><span class="n">loop</span><span class="p">,</span><span class="n">ev_io</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">revents</span><span class="p">);</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">create_socket</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ev_io</span> <span class="n">ev_io_watcher</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">ev_loop</span> <span class="o">*</span><span class="n">loop</span> <span class="o">=</span> <span class="n">ev_loop_new</span><span class="p">(</span><span class="n">EVBACKEND_EPOLL</span><span class="p">);</span>

    <span class="n">ev_io_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev_io_watcher</span><span class="p">,</span> <span class="n">accept_socket_cb</span><span class="p">,</span><span class="n">s</span><span class="p">,</span> <span class="n">EV_READ</span><span class="p">);</span>
    <span class="n">ev_io_start</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ev_io_watcher</span><span class="p">);</span> 
    <span class="n">ev_loop</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">ev_loop_destroy</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">create_socket</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&quot;create socket error </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">so_reuseaddr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">setsockopt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">SOL_SOCKET</span><span class="p">,</span><span class="n">SO_REUSEADDR</span><span class="p">,</span><span class="o">&amp;</span><span class="n">so_reuseaddr</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">so_reuseaddr</span><span class="p">));</span>
    <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
    <span class="n">addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">PF_INET</span><span class="p">;</span>
    <span class="n">addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">PORT</span><span class="p">);</span>
    <span class="n">addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span><span class="n">IP</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="p">))</span><span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&quot;bind socket error </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>


    <span class="k">if</span><span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">32</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&quot;listen socket error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;bind %s,listen %d </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">IP</span><span class="p">,</span><span class="n">PORT</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">accept_socket_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ev_loop</span> <span class="o">*</span><span class="n">loop</span><span class="p">,</span><span class="n">ev_io</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">revents</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">sin</span><span class="p">;</span>
    <span class="kt">socklen_t</span> <span class="n">addrlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="p">);</span>
    <span class="k">do</span><span class="p">{</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sin</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">fd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EAGAIN</span> <span class="o">||</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">EWOULDBLOCK</span><span class="p">){</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="n">ev_io</span><span class="o">*</span> <span class="n">accept_watcher</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ev_io</span><span class="p">));</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">accept_watcher</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ev_io</span><span class="p">));</span>

    <span class="n">ev_io_init</span><span class="p">(</span><span class="n">accept_watcher</span><span class="p">,</span><span class="n">recv_socket_cb</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">EV_READ</span><span class="p">);</span>
    <span class="n">ev_io_start</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span><span class="n">accept_watcher</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define MAX_BUF_LEN  1024</span>
<span class="kt">void</span> <span class="nf">recv_socket_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ev_loop</span> <span class="o">*</span><span class="n">loop</span><span class="p">,</span><span class="n">ev_io</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">revents</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAX_BUF_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">do</span><span class="p">{</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">MAX_BUF_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;recv message:</span><span class="se">\n</span><span class="s">&#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">buf</span><span class="p">);</span>
            <span class="n">ev_io_stop</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span>  <span class="n">w</span><span class="p">);</span>
            <span class="n">ev_io_init</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">write_socket_cb</span><span class="p">,</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="n">EV_WRITE</span><span class="p">);</span>
            <span class="n">ev_io_start</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span><span class="n">w</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;remote socket closed </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EAGAIN</span> <span class="o">||</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EWOULDBLOCK</span><span class="p">){</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="n">close</span><span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span>
    <span class="n">ev_io_stop</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span><span class="n">w</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">write_socket_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ev_loop</span> <span class="o">*</span><span class="n">loop</span><span class="p">,</span><span class="n">ev_io</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">revents</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAX_BUF_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">MAX_BUF_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;this is test message from libev </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="n">write</span><span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span><span class="mi">0</span><span class="p">);</span>

    <span class="n">ev_io_stop</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span>  <span class="n">w</span><span class="p">);</span>
    <span class="n">ev_io_init</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">recv_socket_cb</span><span class="p">,</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="n">EV_READ</span><span class="p">);</span>
    <span class="n">ev_io_start</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span><span class="n">w</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h3>多线程例子</h3>
<p>请<a href="http://www.jiancool.com/article/72062229207/">参考</a></p>
<h3>参考</h3>
<p><a href="http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod">Libev</a></p>
<p><a href="http://www.jiancool.com/article/72062229207/">libev多线程使用例</a></p>
<p><a href="http://blog.chinaunix.net/uid-28458801-id-4463801.html">库-libev：详解</a></p>
    </div><!-- /.entry-content -->
    <div class="comments">
      <h2>Comments !</h2>
      <div id="disqus_thread"></div>
      <script type="text/javascript">
        var disqus_identifier = "posts/2015/09/libev_note.html";
        var disqus_url = "https://geesun.github.io/posts/2015/09/libev_note.html";
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//geesun.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>
    </div>

  </article>
</section>
        <section id="extras" class="body">
                <div class="social">
                        <h2>个人链接</h2>
                        <ul>
                            <li><a href="https://geesun.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                            <li><a href="https://twitter.com/geesun">Twitter</a></li>
                            <li><a href="https://github.com/geesun">Github</a></li>
                            <li><a href="https://geesun.github.io/resume.html">Resume</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <p>Powered by <a href="http://getpelican.com/">Pelican</a>. Theme <a href="https://github.com/blueicefield/pelican-blueidea/">blueidea</a>, inspired by the default theme.</p>
        </footer><!-- /#contentinfo -->

<script type="text/javascript">
    var disqus_shortname = 'geesun';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>