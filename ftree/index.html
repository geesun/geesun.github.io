<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å—å·ä¹ŒçŸ³å¾æ°æ—è°±</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Microsoft YaHei", "PingFang SC", sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            overflow: hidden;
        }

        #header {
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            z-index: 100;
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
        }
        
        #header.hidden {
            max-height: 0;
            padding: 0 20px;
        }

        #header h1 {
            font-size: 18px;
            color: #2c3e50;
            margin: 0;
        }

        #header .stats {
            display: flex;
            gap: 15px;
            font-size: 12px;
            color: #666;
        }

        #header .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #header .stat-value {
            font-size: 16px;
            font-weight: bold;
            color: #3498db;
        }

        #controls {
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 15px;
            display: flex;
            gap: 10px;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
        }
        
        #controls.hidden {
            max-height: 0;
            padding: 0 15px;
        }
        
        #fullscreen-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(52, 152, 219, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            font-size: 14px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 150;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #fullscreen-btn:hover {
            background: rgba(41, 128, 185, 0.95);
            transform: scale(1.1);
        }

        #controls button {
            padding: 6px 12px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s;
        }

        #controls button:hover {
            background: #2980b9;
        }

        #generation-select,
        #person-select {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 12px;
            background: white;
            cursor: pointer;
        }
        
        #generation-select {
            width: 100px;
        }
        
        #person-select {
            width: 120px;
        }

        #search-box {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 12px;
            width: 180px;
        }

        #tree-container {
            width: 100%;
            height: calc(100vh - 95px);
            position: relative;
            overflow: hidden;
            transition: height 0.3s ease-out;
        }
        
        #tree-container.expanded {
            height: 100vh;
        }

        .node rect {
            cursor: pointer;
            transition: all 0.3s;
        }

        .node rect:hover {
            fill: #e8f4f8 !important;
            stroke: #2980b9 !important;
            stroke-width: 3px !important;
        }

        .node.selected circle {
            fill: #e74c3c;
            stroke: #c0392b;
        }

        .node text {
            font-size: 13px;
            font-weight: bold;
            pointer-events: none;
        }

        .node .name-text {
            fill: #2c3e50;
            font-size: 14px;
        }

        .node .gen-text {
            fill: #7f8c8d;
            font-size: 11px;
            font-weight: normal;
        }

        .node .note-text {
            fill: #95a5a6;
            font-size: 10px;
            font-weight: normal;
            font-style: italic;
        }

        .link {
            fill: none;
            stroke: #95a5a6;
            stroke-width: 2px;
        }

        #detail-card {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            padding: 25px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
            z-index: 1000;
        }
        
        /* ç§»åŠ¨ç«¯æ ·å¼ */
        @media (max-width: 768px) {
            #header {
                padding: 8px 10px;
                flex-direction: column;
                gap: 8px;
            }
            
            #header h1 {
                font-size: 14px;
                text-align: center;
            }
            
            #header .stats {
                gap: 10px;
                font-size: 10px;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            #header .stat-value {
                font-size: 13px;
            }
            
            #controls {
                padding: 8px 10px;
                gap: 8px;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            #controls button {
                padding: 6px 10px;
                font-size: 11px;
                flex: 0 0 auto;
            }
            
            #generation-select,
            #person-select {
                font-size: 11px;
                padding: 6px 8px;
                flex: 1 1 calc(50% - 4px);
                min-width: 100px;
            }
            
            #search-box {
                font-size: 11px;
                width: 100%;
                padding: 6px 8px;
                flex: 1 1 100%;
            }
            
            #search-result {
                flex: 1 1 100%;
                text-align: center;
                font-size: 11px;
            }
            
            #fullscreen-btn {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
            
            #tree-container {
                height: calc(100vh - 140px);
            }
            
            #detail-card {
                width: 90vw;
                max-width: 90vw;
                max-height: 85vh;
                padding: 20px;
            }
            
            #detail-card h2 {
                font-size: 18px;
            }
            
            #detail-card .section-title {
                font-size: 14px;
            }
            
            #detail-card .info-row {
                font-size: 13px;
            }
            
            .tooltip {
                font-size: 12px;
                max-width: 200px;
                padding: 8px 12px;
            }
        }

        #detail-card.show {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -45%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }

        #detail-card .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
        }

        #detail-card .close-btn:hover {
            background: #c0392b;
        }

        #detail-card h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 3px solid #3498db;
        }

        #detail-card .section {
            margin: 20px 0;
        }

        #detail-card .section-title {
            font-weight: bold;
            color: #3498db;
            margin-bottom: 8px;
            font-size: 16px;
        }

        #detail-card .info-row {
            margin: 8px 0;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
            line-height: 1.6;
        }

        #detail-card .label {
            color: #7f8c8d;
            font-weight: bold;
            margin-right: 8px;
        }

        #detail-card .children-list,
        #detail-card .siblings-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
        }

        #detail-card .person-tag {
            display: inline-block;
            padding: 4px 12px;
            background: #ecf0f1;
            border-radius: 12px;
            font-size: 13px;
            color: #2c3e50;
            border: 1px solid #bdc3c7;
        }

        #detail-card .person-tag.current {
            background: #e74c3c;
            color: white;
            border-color: #c0392b;
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: none;
            z-index: 999;
        }

        #overlay.show {
            display: block;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            color: #3498db;
        }

        .tooltip {
            position: absolute;
            background: rgba(44, 62, 80, 0.95);
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 13px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
            max-width: 250px;
            line-height: 1.6;
        }

        .tooltip.show {
            opacity: 1;
        }

        /* ===== æ”¯ç³»æµè§ˆè§†å›¾ ===== */
        #branch-view {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100vh;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        }

        #branch-header {
            background: rgba(255, 255, 255, 0.95);
            padding: 18px 25px 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        #branch-header h1 {
            font-size: 22px;
            color: #2c3e50;
            margin: 0 0 5px 0;
        }

        #branch-header .branch-subtitle {
            font-size: 13px;
            color: #7f8c8d;
            margin: 0;
        }

        #branch-tree-container {
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .branch-link {
            fill: none;
            stroke: #bdc3c7;
            stroke-width: 1.5px;
        }

        .branch-node {
            cursor: pointer;
        }

        .branch-node rect {
            transition: filter 0.15s;
        }

        .branch-node rect:hover {
            filter: brightness(0.88);
        }

        .branch-node.loading rect {
            stroke-dasharray: 4;
            animation: dash 1s linear infinite;
        }

        @keyframes dash {
            to { stroke-dashoffset: -8; }
        }

        /* è¿”å›æŒ‰é’® */
        #back-btn {
            padding: 6px 12px;
            background: #e67e22;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s;
        }

        #back-btn:hover {
            background: #d35400;
        }

        /* Toast æç¤º */
        #toast {
            position: fixed;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(44, 62, 80, 0.92);
            color: white;
            padding: 10px 22px;
            border-radius: 20px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 9999;
            white-space: nowrap;
        }

        #toast.show {
            opacity: 1;
        }

        @media (max-width: 768px) {
            #branch-header h1 { font-size: 17px; }
            #branch-header .branch-subtitle { font-size: 11px; }
        }
    </style>
</head>
<body>
    <!-- æ”¯ç³»æµè§ˆè§†å›¾ -->
    <div id="branch-view">
        <div id="branch-header">
            <h1>ğŸŒ³ å—å·ä¹ŒçŸ³å¾æ°æ—è°±</h1>
            <p class="branch-subtitle">ç‚¹å‡»å¶èŠ‚ç‚¹åŠ è½½å¯¹åº”æ”¯ç³»æ—è°±</p>
        </div>
        <div id="branch-tree-container"></div>
    </div>

    <!-- æ—è°±æ ‘è§†å›¾ -->
    <div id="person-view" style="display:none">
    <div id="header">
        <h1>ğŸŒ³ <span id="branch-title">å—å·ä¹ŒçŸ³å¾æ°æ—è°±</span></h1>
        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="total-people">-</div>
                <div>æ€»äººæ•°</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="generation-range">-</div>
                <div>ä¸–ä»£èŒƒå›´</div>
            </div>
        </div>
    </div>

    <div id="controls">
        <button id="back-btn" onclick="goBackToBranchView()">â† è¿”å›æ€»è°±</button>
        <button onclick="resetView()">ğŸ  é‡ç½®è§†å›¾</button>
        <button onclick="expandAll()">â• å±•å¼€å…¨éƒ¨</button>
        <select id="generation-select" onchange="updatePersonSelect()"></select>
        <select id="person-select" onchange="applyRootChange()"></select>
        <input type="text" id="search-box" placeholder="æœç´¢å§“å..." oninput="searchPerson(this.value)">
        <span id="search-result"></span>
    </div>

    <div id="tree-container"></div>
    
    <button id="fullscreen-btn" onclick="toggleFullscreen()" title="å…¨å±/é€€å‡ºå…¨å±">â›¶</button>

    <div id="overlay" onclick="closeDetailCard()"></div>
    
    <div id="detail-card">
        <button class="close-btn" onclick="closeDetailCard()">Ã—</button>
        <div id="detail-content"></div>
    </div>

    <div class="tooltip" id="tooltip"></div>
    </div><!-- /person-view -->

    <div id="toast"></div>

    <script>
        let treeData = null;
        let allPeople = [];
        let root = null;
        let svg = null;
        let g = null;
        let tree = null;
        let selectedNode = null;
        let zoom = null;  // å…¨å±€zoomå®ä¾‹
        let currentRootNid = null;  // å½“å‰æ ¹èŠ‚ç‚¹çš„nid

        // æ”¯ç³»è§†å›¾çŠ¶æ€
        let branchRoot = null;
        let branchSvg = null;
        let branchG = null;
        let branchTree = null;
        let branchZoom = null;
        let currentBranchName = '';

        // åŠ è½½æŒ‡å®šè·¯å¾„çš„æ”¯ç³»æ—è°±æ•°æ®ï¼ˆç”±æ”¯ç³»è§†å›¾è°ƒç”¨ï¼‰
        async function loadPersonData(jsonPath) {
            const response = await fetch(jsonPath);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            return await response.json();
        }

        // åˆå§‹åŒ–ä¸–ä»£é€‰æ‹©å™¨
        function initGenerationSelector(minGen, maxGen, defaultGen) {
            const genSelect = document.getElementById('generation-select');
            genSelect.innerHTML = '<option value="">é€‰æ‹©ä¸–ä»£</option>';
            
            for (let gen = maxGen; gen >= minGen; gen--) {
                const option = document.createElement('option');
                option.value = gen;
                option.textContent = `ç¬¬${gen}ä¸–`;
                if (gen === defaultGen) {
                    option.selected = true;
                }
                genSelect.appendChild(option);
            }
            
            // åˆå§‹åŒ–æ—¶æ›´æ–°äººå‘˜é€‰æ‹©å™¨ï¼ˆä¼ å…¥é»˜è®¤ä¸–ä»£ï¼‰
            updatePersonSelect(defaultGen);
        }
        
        // æ›´æ–°äººå‘˜é€‰æ‹©å™¨
        function updatePersonSelect(generation = null) {
            const genSelect = document.getElementById('generation-select');
            const personSelect = document.getElementById('person-select');
            const selectedGen = generation !== null ? generation : parseInt(genSelect.value);
            
            personSelect.innerHTML = '<option value="">é€‰æ‹©äººå‘˜</option>';
            
            if (!selectedGen) return;
            
            const genPeople = allPeople.filter(p => p.generation === selectedGen);
            
            genPeople.forEach(person => {
                const option = document.createElement('option');
                option.value = person.nid;
                option.textContent = person.name;
                personSelect.appendChild(option);
            });
            
            if (genPeople.length > 0) {
                personSelect.value = genPeople[0].nid;
            }
            
            // å¦‚æœé€‰ä¸­äº†äººå‘˜ï¼Œä¸»åŠ¨è§¦å‘æ›´æ–°ï¼ˆè§£å†³åªæœ‰ä¸€ä¸ªäººæ—¶ä¸è§¦å‘onchangeçš„é—®é¢˜ï¼‰
            if (personSelect.value && personSelect.value !== '') {
                setTimeout(() => applyRootChange(), 50);
            }
        }
        
        // åº”ç”¨æ ¹èŠ‚ç‚¹å˜æ›´
        function applyRootChange() {
            const personSelect = document.getElementById('person-select');
            const selectedNid = personSelect.value;
            
            if (!selectedNid) {
                alert('è¯·å…ˆé€‰æ‹©ä¸–ä»£å’Œäººå‘˜');
                return;
            }
            
            // é‡æ–°æ„å»ºæ ‘
            buildTree(allPeople, selectedNid);
            
            // æ¸…é™¤æ—§çš„SVG
            d3.select('#tree-container').select('svg').remove();
            
            // é‡æ–°åˆå§‹åŒ–æ ‘
            initTree();
        }

        // æ„å»ºæ ‘å½¢ç»“æ„
        function buildTree(people, rootNid = null) {
            console.log('buildTree å¼€å§‹, rootNid:', rootNid);
            
            const peopleMap = {};
            people.forEach(p => peopleMap[p.nid] = {...p, children: []});
            
            // æ‰¾åˆ°æ ¹èŠ‚ç‚¹
            let rootPerson;
            
            if (rootNid && peopleMap[rootNid]) {
                // å¦‚æœæŒ‡å®šäº†æ ¹èŠ‚ç‚¹ï¼Œä½¿ç”¨æŒ‡å®šçš„èŠ‚ç‚¹
                rootPerson = peopleMap[rootNid];
                currentRootNid = rootNid;
                console.log('ä½¿ç”¨æŒ‡å®šæ ¹èŠ‚ç‚¹:', rootPerson.name, 'ç¬¬' + rootPerson.generation + 'ä¸–');
            } else {
                // å¦åˆ™ä½¿ç”¨é»˜è®¤é€»è¾‘ï¼šä¼˜å…ˆé€‰æ‹©ç¬¬1ä¸–çš„äºº
                let roots = [];
                
                const generation1 = people.filter(p => p.generation === 1);
                if (generation1.length > 0) {
                    roots = generation1;
                } else {
                    people.forEach(person => {
                        if (!person.father || 
                            !peopleMap[person.father.nid] || 
                            person.father.nid === person.nid) {
                            roots.push(person);
                        }
                    });
                }
                
                if (roots.length === 0) {
                    console.error('æœªæ‰¾åˆ°æ ¹èŠ‚ç‚¹');
                    alert('é”™è¯¯ï¼šæ— æ³•æ„å»ºæ—è°±æ ‘ï¼Œæœªæ‰¾åˆ°æ ¹èŠ‚ç‚¹æˆ–ç¬¬1ä¸–çš„äºº');
                    return;
                }
                
                roots.sort((a, b) => (a.generation || 999) - (b.generation || 999));
                rootPerson = roots[0];
                currentRootNid = rootPerson.nid;
                console.log('ä½¿ç”¨é»˜è®¤æ ¹èŠ‚ç‚¹:', rootPerson.name, 'ç¬¬' + rootPerson.generation + 'ä¸–');
            }
            
            // æ„å»ºçˆ¶å­å…³ç³»
            people.forEach(person => {
                // å¦‚æœè¿™ä¸ªäººæ˜¯æ ¹èŠ‚ç‚¹ï¼Œè·³è¿‡ï¼ˆä¸æ·»åŠ åˆ°ä»»ä½•äººçš„childrenä¸­ï¼‰
                if (person.nid === rootPerson.nid) {
                    return;
                }
                
                // å¦‚æœè¿™ä¸ªäººæ˜¯ç¬¬1ä¸–ä¸”æ ¹èŠ‚ç‚¹ä¹Ÿæ˜¯ç¬¬1ä¸–ï¼Œè·³è¿‡
                if (person.generation === 1 && rootPerson.generation === 1) {
                    return;
                }
                
                // æ’é™¤çˆ¶äº²æŒ‡å‘è‡ªå·±çš„æƒ…å†µï¼ˆå¾ªç¯å¼•ç”¨ï¼‰
                if (person.father && 
                    peopleMap[person.father.nid] && 
                    person.father.nid !== person.nid) {
                    peopleMap[person.father.nid].children.push(peopleMap[person.nid]);
                }
            });
            
            // æŒ‰ç…§siblings.rankå¯¹æ¯ä¸ªçˆ¶èŠ‚ç‚¹çš„childrenè¿›è¡Œæ’åº
            Object.values(peopleMap).forEach(parent => {
                if (parent.children && parent.children.length > 0) {
                    parent.children.sort((a, b) => {
                        const rankA = a.siblings?.rank || 999;
                        const rankB = b.siblings?.rank || 999;
                        return rankA - rankB;
                    });
                }
            });
            
            treeData = peopleMap[rootPerson.nid];
        }

        // åˆå§‹åŒ–æ ‘å½¢å›¾
        function initTree() {
            const container = document.getElementById('tree-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            svg = d3.select('#tree-container')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            g = svg.append('g');
            
            // æ·»åŠ ç¼©æ”¾å’Œæ‹–æ‹½
            zoom = d3.zoom()
                .scaleExtent([0.1, 3])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            // ä½¿ç”¨ nodeSize è€Œä¸æ˜¯ sizeï¼Œç¡®ä¿æ¯ä¸ªèŠ‚ç‚¹æœ‰å›ºå®šç©ºé—´
            // å·¦å³å¸ƒå±€: [å‚ç›´é—´è·, æ°´å¹³é—´è·]
            tree = d3.tree()
                .nodeSize([100, 180]);
            
            root = d3.hierarchy(treeData);
            root.x0 = 0;
            root.y0 = 0;
            
            // é»˜è®¤æŠ˜å æ·±åº¦å¤§äº2çš„èŠ‚ç‚¹
            if (root.children) {
                root.children.forEach(collapse);
            }
            
            // å…ˆæ›´æ–°æ˜¾ç¤ºèŠ‚ç‚¹
            update(root);
            
            // ç­‰å¾…DOMæ›´æ–°åå±…ä¸­æ˜¾ç¤º
            setTimeout(() => centerNode(root), 300);
        }

        // å±…ä¸­æ˜¾ç¤ºæŒ‡å®šèŠ‚ç‚¹
        function centerNode(source) {
            const container = document.getElementById('tree-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            const scale = 0.85;
            // ä½¿ç”¨å½“å‰ä½ç½® d.y å’Œ d.xï¼Œè€Œä¸æ˜¯æ—§ä½ç½® d.y0 å’Œ d.x0
            // æ°´å¹³æ–¹å‘å±…ä¸­ï¼šä½¿ç”¨ width / 2
            const x = -source.y * scale + width / 2;
            const y = -source.x * scale + height / 2;
            
            const transform = d3.zoomIdentity.translate(x, y).scale(scale);
            svg.transition().duration(750).call(zoom.transform, transform);
        }

        // æŠ˜å èŠ‚ç‚¹
        function collapse(d) {
            if (d.children) {
                d._children = d.children;
                d._children.forEach(collapse);
                d.children = null;
            }
        }

        // æ›´æ–°æ ‘å½¢å›¾
        function update(source) {
            const duration = 300;
            const treeLayout = tree(root);
            const nodes = treeLayout.descendants();
            const links = treeLayout.links();
            
            // nodeSize ä¼šè‡ªåŠ¨è®¡ç®—ä½ç½®ï¼Œä¸éœ€è¦æ‰‹åŠ¨è®¾ç½® y
            
            // æ›´æ–°èŠ‚ç‚¹
            const node = g.selectAll('.node')
                .data(nodes, d => d.data.nid);
            
            // æ–°èŠ‚ç‚¹
            const nodeEnter = node.enter().append('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${source.y0},${source.x0})`)
                .on('click', (event, d) => {
                    if (event.shiftKey) {
                        showDetailCard(d.data);
                    } else {
                        // å…ˆå±…ä¸­è¯¥èŠ‚ç‚¹
                        centerNode(d);
                        // å»¶è¿Ÿä¸€ç‚¹å†å±•å¼€ï¼Œè®©å±…ä¸­åŠ¨ç”»å…ˆå®Œæˆ
                        setTimeout(() => {
                            toggle(d);
                            update(d);
                        }, 400);
                    }
                })
                .on('contextmenu', (event, d) => {
                    // å³é”®ç‚¹å‡»æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯ï¼ˆç§»åŠ¨ç«¯é•¿æŒ‰ä¼šè§¦å‘ï¼‰
                    event.preventDefault();
                    showDetailCard(d.data);
                })
                .on('touchstart', (event, d) => {
                    // ç§»åŠ¨ç«¯é•¿æŒ‰æ£€æµ‹
                    const touchTimer = setTimeout(() => {
                        showDetailCard(d.data);
                    }, 500);
                    d3.select(event.currentTarget).attr('data-touch-timer', touchTimer);
                })
                .on('touchend', (event, d) => {
                    // å–æ¶ˆé•¿æŒ‰è®¡æ—¶å™¨
                    const touchTimer = d3.select(event.currentTarget).attr('data-touch-timer');
                    if (touchTimer) {
                        clearTimeout(touchTimer);
                    }
                })
                .on('touchmove', (event, d) => {
                    // ç§»åŠ¨æ—¶å–æ¶ˆé•¿æŒ‰
                    const touchTimer = d3.select(event.currentTarget).attr('data-touch-timer');
                    if (touchTimer) {
                        clearTimeout(touchTimer);
                    }
                })
                .on('mouseover', (event, d) => showTooltip(event, d.data))
                .on('mouseout', hideTooltip);
            
            // åœ†è§’çŸ©å½¢
            nodeEnter.append('rect')
                .attr('width', 60)
                .attr('height', 30)
                .attr('x', -30)
                .attr('y', -15)
                .attr('rx', 5)
                .attr('ry', 5)
                .style('fill', '#fff')
                .style('stroke', '#3498db')
                .style('stroke-width', '2px');
            
            // å§“åï¼ˆåœ¨æ–¹æ¡†å†…ï¼‰
            nodeEnter.append('text')
                .attr('class', 'name-text')
                .attr('dy', 5)
                .style('text-anchor', 'middle')
                .text(d => d.data.name);
            
            // ä¸–ä»£ï¼ˆåœ¨æ–¹æ¡†ä¸Šæ–¹ï¼‰
            nodeEnter.append('text')
                .attr('class', 'gen-text')
                .attr('dy', -20)
                .style('text-anchor', 'middle')
                .text(d => d.data.generation ? `ç¬¬${d.data.generation}ä¸–` : '');
            
            // å¤‡æ³¨ï¼ˆåœ¨æ–¹æ¡†ä¸‹æ–¹ï¼Œå°å­—ä½“ï¼‰
            nodeEnter.append('text')
                .attr('class', 'note-text')
                .attr('dy', 30)
                .style('text-anchor', 'middle')
                .text(d => {
                    if (!d.data.note) return '';
                    return d.data.note.length > 8 ? d.data.note.substring(0, 8) + '...' : d.data.note;
                });
            
            // æ›´æ–°èŠ‚ç‚¹ä½ç½®ï¼ˆæ°´å¹³å¸ƒå±€ï¼šyæ˜¯æ°´å¹³ï¼Œxæ˜¯å‚ç›´ï¼‰
            const nodeUpdate = nodeEnter.merge(node);
            nodeUpdate.transition()
                .duration(duration)
                .attr('transform', d => `translate(${d.y},${d.x})`);
            
            // ç§»é™¤æ—§èŠ‚ç‚¹
            node.exit().transition()
                .duration(duration)
                .attr('transform', d => `translate(${source.y},${source.x})`)
                .remove();
            
            // æ›´æ–°è¿çº¿
            const link = g.selectAll('.link')
                .data(links, d => d.target.data.nid);
            
            const linkEnter = link.enter().insert('path', 'g')
                .attr('class', 'link')
                .attr('d', d => {
                    const o = {x: source.x0, y: source.y0};
                    return diagonal(o, o);
                });
            
            linkEnter.merge(link).transition()
                .duration(duration)
                .attr('d', d => diagonal(d.source, d.target));
            
            link.exit().transition()
                .duration(duration)
                .attr('d', d => {
                    const o = {x: source.x, y: source.y};
                    return diagonal(o, o);
                })
                .remove();
            
            // ä¿å­˜æ—§ä½ç½®
            nodes.forEach(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });
        }

        // å¯¹è§’çº¿è¿æ¥ï¼ˆæ°´å¹³æ–¹å‘ï¼‰
        function diagonal(s, d) {
            return `M ${s.y} ${s.x}
                    C ${(s.y + d.y) / 2} ${s.x},
                      ${(s.y + d.y) / 2} ${d.x},
                      ${d.y} ${d.x}`;
        }

        // åˆ‡æ¢èŠ‚ç‚¹å±•å¼€/æŠ˜å 
        function toggle(d) {
            if (d.children) {
                d._children = d.children;
                d.children = null;
            } else {
                d.children = d._children;
                d._children = null;
            }
        }

        // æ˜¾ç¤ºæç¤ºæ¡†
        function showTooltip(event, data) {
            const tooltip = document.getElementById('tooltip');
            let html = `<strong>${data.name}</strong><br>`;
            if (data.generation) html += `ç¬¬${data.generation}ä¸–<br>`;
            if (data.note) html += `${data.note}<br>`;
            if (data.father) html += `çˆ¶: ${data.father.name}<br>`;
            if (data.children.length > 0) html += `å­å¥³: ${data.children.length}äºº<br>`;
            // æ ¹æ®è®¾å¤‡ç±»å‹æ˜¾ç¤ºä¸åŒçš„æ“ä½œæç¤º
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (isMobile) {
                html += `<em>é•¿æŒ‰æŸ¥çœ‹è¯¦æƒ…</em>`;
            } else {
                html += `<em>å³é”®æŸ¥çœ‹è¯¦æƒ…</em>`;
            }

            tooltip.innerHTML = html;
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY + 10) + 'px';
            tooltip.classList.add('show');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('show');
        }

        // æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯å¡ç‰‡
        function showDetailCard(person) {
            const card = document.getElementById('detail-card');
            const content = document.getElementById('detail-content');
            
            let html = `<h2>${person.name} ${person.generation ? `(ç¬¬${person.generation}ä¸–)` : ''}</h2>`;
            
            // åŸºæœ¬ä¿¡æ¯
            html += `<div class="section">`;
            html += `<div class="section-title">ğŸ“‹ åŸºæœ¬ä¿¡æ¯</div>`;
            if (person.note) html += `<div class="info-row"><span class="label">å¤‡æ³¨:</span>${person.note}</div>`;
            if (person.relation_to_father) html += `<div class="info-row"><span class="label">æ’è¡Œ:</span>${person.relation_to_father}</div>`;
            html += `</div>`;
            
            // çˆ¶äº²
            if (person.father) {
                html += `<div class="section">`;
                html += `<div class="section-title">ğŸ‘¨ çˆ¶äº²</div>`;
                html += `<div class="info-row">${person.father.name}</div>`;
                html += `</div>`;
            }
            
            // å­å¥³
            if (person.children && person.children.length > 0) {
                html += `<div class="section">`;
                html += `<div class="section-title">ğŸ‘¶ å­å¥³ (${person.children.length}äºº)</div>`;
                html += `<div class="children-list">`;
                // æŒ‰ç…§siblings.rankæ’åºå­å¥³
                const sortedChildren = [...person.children].sort((a, b) => {
                    const rankA = a.siblings?.rank || 999;
                    const rankB = b.siblings?.rank || 999;
                    return rankA - rankB;
                });
                sortedChildren.forEach(child => {
                    html += `<span class="person-tag">${child.relation || ''} ${child.name}</span>`;
                });
                html += `</div></div>`;
            }
            
            // å…„å¼Ÿå§å¦¹
            if (person.siblings && person.siblings.list) {
                html += `<div class="section">`;
                html += `<div class="section-title">ğŸ‘¥ å…„å¼Ÿå§å¦¹ (${person.siblings.total_count}äºº)</div>`;
                html += `<div class="siblings-list">`;
                person.siblings.list.forEach(sibling => {
                    const isCurrent = sibling.includes(person.name);
                    html += `<span class="person-tag ${isCurrent ? 'current' : ''}">${sibling}</span>`;
                });
                html += `</div></div>`;
            }
            
            // è¯¦ç»†æè¿°
            if (person.detail_info && person.detail_info.raw_text) {
                html += `<div class="section">`;
                html += `<div class="section-title">ğŸ“œ è¯¦ç»†ä¿¡æ¯</div>`;
                html += `<div class="info-row" style="white-space: pre-wrap;">${person.detail_info.raw_text}</div>`;
                html += `</div>`;
            }
            
            // è®³å·
            if (person.detail_info && (person.detail_info.aliases.hui || person.detail_info.aliases.hao)) {
                html += `<div class="section">`;
                html += `<div class="section-title">ğŸ·ï¸ è®³å·</div>`;
                if (person.detail_info.aliases.hui) {
                    html += `<div class="info-row"><span class="label">è®³:</span>${person.detail_info.aliases.hui}</div>`;
                }
                if (person.detail_info.aliases.hao) {
                    html += `<div class="info-row"><span class="label">å·:</span>${person.detail_info.aliases.hao}</div>`;
                }
                html += `</div>`;
            }
            
            // ç”Ÿå’ä¿¡æ¯
            if (person.detail_info && (person.detail_info.birth || person.detail_info.death)) {
                html += `<div class="section">`;
                html += `<div class="section-title">â³ ç”Ÿå’ä¿¡æ¯</div>`;
                if (person.detail_info.birth) {
                    html += `<div class="info-row"><span class="label">ç”Ÿ:</span>${person.detail_info.birth}</div>`;
                }
                if (person.detail_info.death) {
                    html += `<div class="info-row"><span class="label">æ®:</span>${person.detail_info.death}</div>`;
                }
                if (person.detail_info.burial) {
                    html += `<div class="info-row"><span class="label">è‘¬:</span>${person.detail_info.burial}</div>`;
                }
                html += `</div>`;
            }
            
            content.innerHTML = html;
            card.classList.add('show');
            document.getElementById('overlay').classList.add('show');
        }

        function closeDetailCard() {
            document.getElementById('detail-card').classList.remove('show');
            document.getElementById('overlay').classList.remove('show');
        }

        // é‡ç½®è§†å›¾
        function resetView() {
            // é‡æ–°å±•å¼€æ‰€æœ‰èŠ‚ç‚¹
            root.each(d => {
                if (d._children) {
                    d.children = d._children;
                    d._children = null;
                }
            });
            
            // ç„¶åæŠ˜å æ·±åº¦å¤§äº2çš„èŠ‚ç‚¹ï¼ˆæ¢å¤åˆ°åˆå§‹çŠ¶æ€ï¼‰
            if (root.children) {
                root.children.forEach(collapse);
            }
            
            // æ›´æ–°æ˜¾ç¤º
            update(root);
            
            // å»¶è¿Ÿåå±…ä¸­
            setTimeout(() => centerNode(root), 300);
        }
        
        // å®Œå…¨æŠ˜å èŠ‚ç‚¹åŠå…¶æ‰€æœ‰å­èŠ‚ç‚¹
        function collapseAll(d) {
            if (d.children) {
                d._children = d.children;
                d._children.forEach(collapseAll);
                d.children = null;
            }
        }

        // å±•å¼€å…¨éƒ¨
        function expandAll() {
            root.each(d => {
                if (d._children) {
                    d.children = d._children;
                    d._children = null;
                }
            });
            update(root);
        }

        // æœç´¢äººå‘˜
        function searchPerson(query) {
            const result = document.getElementById('search-result');
            if (!query) {
                result.textContent = '';
                return;
            }
            
            const matches = allPeople.filter(p => p.name.includes(query));
            result.textContent = matches.length > 0 ? `æ‰¾åˆ° ${matches.length} äºº` : 'æœªæ‰¾åˆ°';
            
            if (matches.length > 0) {
                // æ‰¾åˆ°ç¬¬ä¸€ä¸ªåŒ¹é…çš„äººåœ¨æ ‘ä¸­çš„èŠ‚ç‚¹
                const person = matches[0];
                const found = findNodeByNid(root, person.nid);
                
                if (found) {
                    // å±•å¼€ä»æ ¹èŠ‚ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹çš„è·¯å¾„
                    expandPathToNode(found);
                    // æ›´æ–°è§†å›¾
                    update(root);
                    // å±…ä¸­æ˜¾ç¤ºç›®æ ‡èŠ‚ç‚¹
                    centerNode(found);
                    // é«˜äº®æ˜¾ç¤º
                    highlightPerson(person.nid);
                }
            }
        }
        
        // æ ¹æ®nidæŸ¥æ‰¾èŠ‚ç‚¹
        function findNodeByNid(current, nid) {
            if (current.data.nid === nid) {
                return current;
            }
            
            const children = current.children || current._children;
            if (children) {
                for (let child of children) {
                    const found = findNodeByNid(child, nid);
                    if (found) return found;
                }
            }
            
            return null;
        }
        
        // å±•å¼€ä»æ ¹èŠ‚ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹çš„è·¯å¾„
        function expandPathToNode(target) {
            // æ‰¾åˆ°ä»æ ¹åˆ°ç›®æ ‡çš„è·¯å¾„
            const path = [];
            findPath(root, target, path);
            
            // å±•å¼€è·¯å¾„ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹
            path.forEach(node => {
                if (node._children) {
                    node.children = node._children;
                    node._children = null;
                }
            });
        }
        
        // æŸ¥æ‰¾ä»æ ¹èŠ‚ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹çš„è·¯å¾„
        function findPath(current, target, path) {
            path.push(current);
            
            if (current === target) {
                return true;
            }
            
            const children = current.children || current._children;
            if (children) {
                for (let child of children) {
                    if (findPath(child, target, path)) {
                        return true;
                    }
                }
            }
            
            path.pop();
            return false;
        }

        // é«˜äº®æ˜¾ç¤ºæŒ‡å®šäººå‘˜
        function highlightPerson(nid) {
            d3.selectAll('.node').classed('selected', false);
            d3.selectAll('.node').filter(d => d.data.nid === nid).classed('selected', true);
        }

        // åˆ‡æ¢å…¨å±æ¨¡å¼
        function toggleFullscreen() {
            const header = document.getElementById('header');
            const controls = document.getElementById('controls');
            const treeContainer = document.getElementById('tree-container');
            const btn = document.getElementById('fullscreen-btn');
            
            header.classList.toggle('hidden');
            controls.classList.toggle('hidden');
            treeContainer.classList.toggle('expanded');
            
            // æ”¹å˜æŒ‰é’®å›¾æ ‡
            if (header.classList.contains('hidden')) {
                btn.textContent = 'âœ–';  // é€€å‡ºå…¨å±
            } else {
                btn.textContent = 'â›¶';  // å…¨å±
            }
            
            // è°ƒæ•´SVGå¤§å°ä»¥é€‚åº”æ–°çš„å®¹å™¨å°ºå¯¸
            setTimeout(() => {
                const width = treeContainer.clientWidth;
                const height = treeContainer.clientHeight;
                if (svg) {
                    svg.attr('width', width).attr('height', height);
                }
            }, 350);
        }

        // =====================================================
        // æ”¯ç³»æµè§ˆè§†å›¾
        // =====================================================

        // ä¸ºæ¯ä¸ªèŠ‚ç‚¹è®¡ç®—å¯¹åº”çš„JSONè·¯å¾„ï¼ˆæ ¹æ®åœ¨æ ‘ä¸­çš„ä½ç½®ï¼‰
        function addJsonPaths(node, parentPath) {
            const curPath = parentPath ? `${parentPath}/${node.name}` : node.name;
            node.jsonPath = `${curPath}/${node.name}.json`;
            node._boxW = Math.max(90, node.name.length * 13 + 24);
            (node.children || []).forEach(c => addJsonPaths(c, curPath));
        }

        // åŒå±‚èŠ‚ç‚¹ç»Ÿä¸€æˆæœ€å¤§å®½åº¦
        function normalizeBoxWidths(root) {
            const maxByDepth = {};
            function collect(node, depth) {
                maxByDepth[depth] = Math.max(maxByDepth[depth] || 0, node._boxW);
                (node.children || []).forEach(c => collect(c, depth + 1));
            }
            collect(root, 0);
            function apply(node, depth) {
                node._boxW = maxByDepth[depth];
                (node.children || []).forEach(c => apply(c, depth + 1));
            }
            apply(root, 0);
        }

        // åŠ è½½å¹¶æ¸²æŸ“æ”¯ç³»æµè§ˆè§†å›¾
        async function loadBranchData() {
            showBranchView();
            try {
                const resp = await fetch('branch.json');
                if (!resp.ok) throw new Error('branch.json not found');
                const data = await resp.json();
                addJsonPaths(data, '');
                normalizeBoxWidths(data);
                renderBranchTree(data);
            } catch (e) {
                console.error('åŠ è½½æ”¯ç³»æ•°æ®å¤±è´¥:', e);
                showToast('æ— æ³•åŠ è½½ branch.jsonï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨');
            }
        }

        // æ¸²æŸ“æ”¯ç³»æ ‘
        function renderBranchTree(data) {
            const container = document.getElementById('branch-tree-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            d3.select('#branch-tree-container').select('svg').remove();

            branchSvg = d3.select('#branch-tree-container')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            branchG = branchSvg.append('g');

            branchZoom = d3.zoom()
                .scaleExtent([0.15, 3])
                .on('zoom', (event) => branchG.attr('transform', event.transform));

            branchSvg.call(branchZoom);

            branchTree = d3.tree().nodeSize([44, 300]);

            branchRoot = d3.hierarchy(data);
            branchRoot.x0 = 0;
            branchRoot.y0 = 0;

            updateBranchTree(branchRoot);
            setTimeout(() => {
                const scale = 0.85;
                const x = width / 8;
                const y = height / 2;
                branchSvg.transition().duration(600).call(
                    branchZoom.transform,
                    d3.zoomIdentity.translate(x, y).scale(scale)
                );
            }, 300);
        }

        // æ›´æ–°æ”¯ç³»æ ‘æ¸²æŸ“
        function updateBranchTree(source) {
            const duration = 280;
            const BOX_H = 32;

            const treeLayout = branchTree(branchRoot);
            const nodes = treeLayout.descendants();
            const links = treeLayout.links();

            const node = branchG.selectAll('.branch-node')
                .data(nodes, d => d.data.name + (d.parent ? d.parent.data.name : ''));

            const nodeEnter = node.enter().append('g')
                .attr('class', 'branch-node')
                .attr('transform', `translate(${source.y0},${source.x0})`)
                .on('click', (event, d) => onBranchNodeClick(event, d))
                .on('touchstart', (event, d) => {
                    event.stopPropagation();
                    const t = event.touches[0];
                    d._touchStartX = t.clientX;
                    d._touchStartY = t.clientY;
                }, { passive: true })
                .on('touchend', (event, d) => {
                    event.stopPropagation();
                    const t = event.changedTouches[0];
                    const dx = Math.abs(t.clientX - (d._touchStartX || 0));
                    const dy = Math.abs(t.clientY - (d._touchStartY || 0));
                    if (dx < 10 && dy < 10) {
                        event.preventDefault();
                        onBranchNodeClick(event, d);
                    }
                });

            // èƒŒæ™¯çŸ©å½¢ï¼ˆå®½åº¦æŒ‰åç§°é•¿åº¦åŠ¨æ€è®¡ç®—ï¼‰
            nodeEnter.append('rect')
                .attr('width', d => d.data._boxW)
                .attr('height', BOX_H)
                .attr('x', d => -d.data._boxW / 2)
                .attr('y', -BOX_H / 2)
                .attr('rx', 7)
                .attr('ry', 7)
                .style('fill', d => d.depth === 0 ? '#2c3e50' : '#d6eaf8')
                .style('stroke', d => d.depth === 0 ? '#1a252f' : '#2980b9')
                .style('stroke-width', '1.8px');

            // èŠ‚ç‚¹åç§°æ–‡å­—ï¼ˆå…¨ç§°æ˜¾ç¤ºï¼‰
            nodeEnter.append('text')
                .attr('class', 'branch-label')
                .attr('dy', 4)
                .style('text-anchor', 'middle')
                .style('font-size', '12px')
                .style('pointer-events', 'none')
                .style('fill', d => d.depth === 0 ? '#fff' : '#2c3e50')
                .text(d => d.data.name);

            const nodeUpdate = nodeEnter.merge(node);

            nodeUpdate.transition().duration(duration)
                .attr('transform', d => `translate(${d.y},${d.x})`);

            nodeUpdate.select('rect')
                .style('fill', d => d.depth === 0 ? '#2c3e50' : '#d6eaf8')
                .style('stroke', d => d.depth === 0 ? '#1a252f' : '#2980b9');

            node.exit().transition().duration(duration)
                .attr('transform', `translate(${source.y},${source.x})`)
                .style('opacity', 0)
                .remove();

            const link = branchG.selectAll('.branch-link')
                .data(links, d => d.target.data.name + (d.target.parent ? d.target.parent.data.name : ''));

            const linkEnter = link.enter().insert('path', 'g')
                .attr('class', 'branch-link')
                .attr('d', () => {
                    const o = { x: source.x0, y: source.y0 };
                    return branchDiagonal(o, o);
                });

            linkEnter.merge(link).transition().duration(duration)
                .attr('d', d => branchDiagonal(d.source, d.target));

            link.exit().transition().duration(duration)
                .attr('d', () => {
                    const o = { x: source.x, y: source.y };
                    return branchDiagonal(o, o);
                })
                .remove();

            nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });
        }

        function branchDiagonal(s, d) {
            const sHalf = s.data ? s.data._boxW / 2 : 0;
            const dHalf = d.data ? d.data._boxW / 2 : 0;
            const sx = s.y + sHalf;  // æºèŠ‚ç‚¹å³è¾¹ç¼˜ä¸­å¿ƒ
            const dx = d.y - dHalf;  // ç›®æ ‡èŠ‚ç‚¹å·¦è¾¹ç¼˜ä¸­å¿ƒ
            const mx = (sx + dx) / 2;
            return `M ${sx} ${s.x}
                    C ${mx} ${s.x},
                      ${mx} ${d.x},
                      ${dx} ${d.x}`;
        }

        // ç‚¹å‡»æ”¯ç³»èŠ‚ç‚¹ï¼šå°è¯•åŠ è½½æ—è°± JSONï¼Œå¤±è´¥åˆ™å±•å¼€/æŠ˜å 
        async function onBranchNodeClick(event, d) {
            if (d.depth === 0) return;  // æ ¹èŠ‚ç‚¹ä¸å“åº”

            const nodeData = d.data;

            // å°è¯•åŠ è½½å¯¹åº” JSON
            let people = null;
            try {
                const resp = await fetch(nodeData.jsonPath);
                if (resp.ok) {
                    const json = await resp.json();
                    if (Array.isArray(json) && json.length > 0) people = json;
                }
            } catch (_) { /* network error â†’ fall through */ }

            if (people) {
                // æˆåŠŸï¼šåˆ‡æ¢åˆ°æ—è°±æ ‘è§†å›¾
                currentBranchName = nodeData.name;
                document.getElementById('branch-title').textContent = nodeData.name;
                document.title = nodeData.name + ' - å—å·ä¹ŒçŸ³å¾æ°æ—è°±';
                allPeople = people;

                const generations = people.map(p => p.generation).filter(g => g != null);
                const minGen = Math.min(...generations);
                const maxGen = Math.max(...generations);
                document.getElementById('total-people').textContent = people.length;
                document.getElementById('generation-range').textContent = `${minGen}-${maxGen}ä¸–`;

                // ä»çœŸæ­£çš„æ ¹èŠ‚ç‚¹å¼€å§‹ï¼ˆç¬¬ä¸€ä¸– / æ²¡æœ‰çˆ¶èŠ‚ç‚¹çš„äººï¼‰
                buildTree(people, null);
                if (!treeData) return;

                showPersonView();
                d3.select('#tree-container').select('svg').remove();
                initTree();
                initGenerationSelector(minGen, maxGen, minGen);
            } else {
                showToast(`ã€Œ${nodeData.name}ã€æš‚æ— æ—è°±æ•°æ®`);
            }
        }

        // åˆ‡æ¢åˆ°æ”¯ç³»è§†å›¾
        function showBranchView() {
            document.getElementById('branch-view').style.display = 'flex';
            document.getElementById('person-view').style.display = 'none';
        }

        // åˆ‡æ¢åˆ°æ—è°±æ ‘è§†å›¾
        function showPersonView() {
            document.getElementById('branch-view').style.display = 'none';
            document.getElementById('person-view').style.display = 'block';
        }

        // è¿”å›æ”¯ç³»è§†å›¾
        function goBackToBranchView() {
            document.getElementById('search-box').value = '';
            document.getElementById('search-result').textContent = '';
            showBranchView();
        }

        // æ˜¾ç¤º Toast æç¤º
        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2800);
        }

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–ï¼ˆå…ˆæ˜¾ç¤ºæ”¯ç³»è§†å›¾ï¼‰
        window.addEventListener('load', loadBranchData);
    </script>
</body>
</html>
